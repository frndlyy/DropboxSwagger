{
  "info": {
    "version": "1.0.0", 
    "description": "The Dropbox API allows developers to work with files in Dropbox, including advanced functionality like full-text search, thumbnails, and sharing.", 
    "title": "Dropbox User API v2"
  }, 
  "paths": {
    "/files/properties/update": {
      "post": {
        "operationId": "FilesPropertiesUpdate", 
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UpdatePropertiesError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpdatePropertiesArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Properties - Update"
      }
    }, 
    "/files/move": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RelocationError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/Metadata"
            }
          }
        }, 
        "operationId": "FilesMove", 
        "description": "Move a file or folder to a different location in the user's Dropbox.\nIf the source path is a folder all its contents will be moved.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RelocationArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Move"
      }
    }, 
    "/sharing/relinquish_file_membership": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RelinquishFileMembershipError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "SharingRelinquishFileMembership", 
        "description": "The current user relinquishes their membership in the designated file. Note that the current user may still have inherited access to this file through the parent folder.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RelinquishFileMembershipArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Relinquish File Membership"
      }
    }, 
    "/sharing/list_folder_members": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SharedFolderAccessError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedFolderMembers"
            }
          }
        }, 
        "operationId": "SharingListFolderMembers", 
        "description": "Returns shared folder membership by its folder ID.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFolderMembersArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List Folder Members"
      }
    }, 
    "/sharing/get_folder_metadata": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SharedFolderAccessError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedFolderMetadata"
            }
          }
        }, 
        "operationId": "SharingGetFolderMetadata", 
        "description": "Returns shared folder metadata by its folder ID.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetMetadataArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Get Folder Metadata"
      }
    }, 
    "/users/get_current_account": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FullAccount"
            }
          }
        }, 
        "operationId": "UsersGetCurrentAccount", 
        "description": "Get information about the current user's account.", 
        "parameters": [
          {
            "schema": {
              "type": "null"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Users - Get Current Account"
      }
    }, 
    "/paper/docs/users/list": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListUsersOnPaperDocResponse"
            }
          }
        }, 
        "operationId": "PaperDocsUsersList", 
        "description": "Lists all users who visited the Paper doc or users with explicit access. This call excludes users who have been removed. The list is sorted by the date of the visit or the share date.\nThe list will include both users, the explicitly shared ones as well as those who came in using the Paper url link.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListUsersOnPaperDocArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Users - List"
      }
    }, 
    "/sharing/unshare_file": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UnshareFileError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "SharingUnshareFile", 
        "description": "Remove all members from this file. Does not remove inherited members.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UnshareFileArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Unshare File"
      }
    }, 
    "/sharing/revoke_shared_link": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RevokeSharedLinkError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "SharingRevokeSharedLink", 
        "description": "Revoke a shared link.\nNote that even after revoking a shared link to a file, the file may be accessible if there are shared links leading to any of the file parent folders. To list all shared links that enable access to a specific file, you can use the :route:`list_shared_links` with the file as the :field:`ListSharedLinksArg.path` argument.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RevokeSharedLinkArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Revoke Shared Link"
      }
    }, 
    "/sharing/check_remove_member_job_status": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/RemoveMemberJobStatus"
            }
          }
        }, 
        "operationId": "SharingCheckRemoveMemberJobStatus", 
        "description": "Returns the status of an asynchronous job for sharing a folder.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Check Remove Member Job Status"
      }
    }, 
    "/sharing/update_file_member": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/FileMemberActionError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/MemberAccessLevelResult"
            }
          }
        }, 
        "operationId": "SharingUpdateFileMember", 
        "description": "Changes a member's access on a shared file.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpdateFileMemberArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Update File Member"
      }
    }, 
    "/files/upload_session/finish_batch/check": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/UploadSessionFinishBatchJobStatus"
            }
          }
        }, 
        "operationId": "FilesUploadSessionFinishBatchCheck", 
        "description": "Returns the status of an asynchronous job for :route:`upload_session/finish_batch`. If success, it returns list of result for each entry.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Upload Session - Finish Batch - Check"
      }
    }, 
    "/files/delete_batch": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/DeleteBatchLaunch"
            }
          }
        }, 
        "operationId": "FilesDeleteBatch", 
        "description": "Delete multiple files/folders at once.\nThis route is asynchronous, which returns a job ID immediately and runs the delete batch asynchronously. Use :route:`delete_batch/check` to check the job status.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DeleteBatchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Delete Batch"
      }
    }, 
    "/files/create_folder_batch/check": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/CreateFolderBatchJobStatus"
            }
          }
        }, 
        "operationId": "FilesCreateFolderBatchCheck", 
        "description": "Returns the status of an asynchronous job for :route:`create_folder_batch`. If success, it returns list of result for each entry.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Create Folder Batch - Check"
      }
    }, 
    "/sharing/mount_folder": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/MountFolderError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedFolderMetadata"
            }
          }
        }, 
        "operationId": "SharingMountFolder", 
        "description": "The current user mounts the designated folder.\nMount a shared folder for a user after they have been added as a member. Once mounted, the shared folder will appear in their Dropbox.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/MountFolderArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Mount Folder"
      }
    }, 
    "/files/restore": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RestoreError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMetadata"
            }
          }
        }, 
        "operationId": "FilesRestore", 
        "description": "Restore a file to a specific revision.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RestoreArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Restore"
      }
    }, 
    "/file_requests/update": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UpdateFileRequestError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileRequest"
            }
          }
        }, 
        "operationId": "FileRequestsUpdate", 
        "description": "Update a file request.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpdateFileRequestArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Requests - Update"
      }
    }, 
    "/file_properties/templates/remove_for_team": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesRemoveForTeam", 
        "description": "Permanently removes the specified template created from :route:`templates/add_for_user`. All properties associated with the template will also be removed. This action cannot be undone.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RemoveTemplateArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - Remove For Team"
      }
    }, 
    "/files/properties/template/get": {
      "post": {
        "operationId": "FilesPropertiesTemplateGet", 
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/GetTemplateResult"
            }
          }
        }, 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetTemplateArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Properties - Template - Get"
      }
    }, 
    "/paper/docs/get_folder_info": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FoldersContainingPaperDoc"
            }
          }
        }, 
        "operationId": "PaperDocsGetFolderInfo", 
        "description": "Retrieves folder information for the given Paper doc. This includes:\n  - folder sharing policy; permissions for subfolders are set by the top-level folder.\n  - full 'filepath', i.e. the list of folders (both folderId and folderName) from     the root folder to the folder directly containing the Paper doc.\n\nNote: If the Paper doc is not in any folder (aka unfiled) the response will be empty.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RefPaperDoc"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Get Folder Info"
      }
    }, 
    "/files/copy_batch": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/RelocationBatchLaunch"
            }
          }
        }, 
        "operationId": "FilesCopyBatch", 
        "description": "Copy multiple files or folders to different locations at once in the user's Dropbox.\nIf :field:`RelocationBatchArg.allow_shared_folder` is false, this route is atomic. If on entry failes, the whole transaction will abort. If :field:`RelocationBatchArg.allow_shared_folder` is true, not atomicity is guaranteed, but you will be able to copy the contents of shared folders to new locations.\nThis route will return job ID immediately and do the async copy job in background. Please use :route:`copy_batch/check` to check the job status.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RelocationBatchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Copy Batch"
      }
    }, 
    "/file_properties/properties/search": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PropertiesSearchError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/PropertiesSearchResult"
            }
          }
        }, 
        "operationId": "FilePropertiesPropertiesSearch", 
        "description": "Search across property templates for particular property field values.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PropertiesSearchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Properties - Search"
      }
    }, 
    "/files/delete": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DeleteError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/Metadata"
            }
          }
        }, 
        "operationId": "FilesDelete", 
        "description": "Delete the file or folder at a given path.\nIf the path is a folder, all its contents will be deleted too.\nA successful response indicates that the file or folder was deleted. The returned metadata will be the corresponding :type:`FileMetadata` or :type:`FolderMetadata` for the item at time of deletion, and not a :type:`DeletedMetadata` object.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DeleteArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Delete"
      }
    }, 
    "/files/properties/add": {
      "post": {
        "operationId": "FilesPropertiesAdd", 
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/AddPropertiesError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AddPropertiesArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Properties - Add"
      }
    }, 
    "/sharing/check_share_job_status": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ShareFolderJobStatus"
            }
          }
        }, 
        "operationId": "SharingCheckShareJobStatus", 
        "description": "Returns the status of an asynchronous job for sharing a folder.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Check Share Job Status"
      }
    }, 
    "/files/get_thumbnail_batch": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetThumbnailBatchError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/GetThumbnailBatchResult"
            }
          }
        }, 
        "operationId": "FilesGetThumbnailBatch", 
        "description": "Get thumbnails for a list of images. We allow up to 25 thumbnails in a single batch.\nThis method currently supports files with the following file extensions: jpg, jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't be converted to a thumbnail.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetThumbnailBatchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Get Thumbnail Batch"
      }
    }, 
    "/sharing/remove_folder_member": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RemoveFolderMemberError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/LaunchResultBase"
            }
          }
        }, 
        "operationId": "SharingRemoveFolderMember", 
        "description": "Allows an owner or editor (if the ACL update policy allows) of a shared folder to remove another member.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RemoveFolderMemberArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Remove Folder Member"
      }
    }, 
    "/sharing/update_folder_member": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UpdateFolderMemberError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/MemberAccessLevelResult"
            }
          }
        }, 
        "operationId": "SharingUpdateFolderMember", 
        "description": "Allows an owner or editor of a shared folder to update another member's permissions.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpdateFolderMemberArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Update Folder Member"
      }
    }, 
    "/sharing/create_shared_link_with_settings": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/CreateSharedLinkWithSettingsError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedLinkMetadata"
            }
          }
        }, 
        "operationId": "SharingCreateSharedLinkWithSettings", 
        "description": "Create a shared link with custom settings. If no settings are given then the default visibility is :field:`RequestedVisibility.public` (The resolved visibility, though, may depend on other aspects such as team and shared folder settings).", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CreateSharedLinkWithSettingsArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Create Shared Link With Settings"
      }
    }, 
    "/file_properties/properties/update": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UpdatePropertiesError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "FilePropertiesPropertiesUpdate", 
        "description": "Add, update or remove properties associated with the supplied file and templates. This endpoint should be used instead of :route:`properties/overwrite` when property groups are being updated via a \"delta\" instead of via a \"snapshot\" . In other words, this endpoint will not delete any omitted fields from a property group, whereas :route:`properties/overwrite` will delete any fields that are omitted from a property group.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpdatePropertiesArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Properties - Update"
      }
    }, 
    "/sharing/unmount_folder": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UnmountFolderError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "SharingUnmountFolder", 
        "description": "The current user unmounts the designated folder. They can re-mount the folder at a later time using :route:`mount_folder`.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UnmountFolderArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Unmount Folder"
      }
    }, 
    "/sharing/list_received_files": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SharingUserError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFilesResult"
            }
          }
        }, 
        "operationId": "SharingListReceivedFiles", 
        "description": "Returns a list of all files shared with current user.\n Does not include files the user has received via shared folders, and does  not include unclaimed invitations.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFilesArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List Received Files"
      }
    }, 
    "/paper/docs/sharing_policy/set": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "PaperDocsSharingPolicySet", 
        "description": "Sets the default sharing policy for the given Paper doc. The default 'team_sharing_policy' can be changed only by teams, omit this field for personal accounts.\n\nNote: 'public_sharing_policy' cannot be set to the value 'disabled' because this setting can be changed only via the team admin console.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PaperDocSharingPolicy"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Sharing Policy - Set"
      }
    }, 
    "/files/properties/remove": {
      "post": {
        "operationId": "FilesPropertiesRemove", 
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RemovePropertiesError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RemovePropertiesArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Properties - Remove"
      }
    }, 
    "/files/copy_batch/check": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/RelocationBatchJobStatus"
            }
          }
        }, 
        "operationId": "FilesCopyBatchCheck", 
        "description": "Returns the status of an asynchronous job for :route:`copy_batch`. If success, it returns list of results for each entry.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Copy Batch - Check"
      }
    }, 
    "/files/move_batch/check": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/RelocationBatchJobStatus"
            }
          }
        }, 
        "operationId": "FilesMoveBatchCheck", 
        "description": "Returns the status of an asynchronous job for :route:`move_batch`. If success, it returns list of results for each entry.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Move Batch - Check"
      }
    }, 
    "/files/list_folder/get_latest_cursor": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFolderError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFolderGetLatestCursorResult"
            }
          }
        }, 
        "operationId": "FilesListFolderGetLatestCursor", 
        "description": "A way to quickly get a cursor for the folder's state. Unlike :route:`list_folder`, :route:`list_folder/get_latest_cursor` doesn't return any entries. This endpoint is for app which only needs to know about new files and modifications and doesn't need to know about files that already exist in Dropbox.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFolderArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - List Folder - Get Latest Cursor"
      }
    }, 
    "/paper/docs/sharing_policy/get": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharingPolicy"
            }
          }
        }, 
        "operationId": "PaperDocsSharingPolicyGet", 
        "description": "Gets the default sharing policy for the given Paper doc.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RefPaperDoc"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Sharing Policy - Get"
      }
    }, 
    "/sharing/share_folder": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ShareFolderError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ShareFolderLaunch"
            }
          }
        }, 
        "operationId": "SharingShareFolder", 
        "description": "Share a folder with collaborators.\nMost sharing will be completed synchronously. Large folders will be completed asynchronously. To make testing the async case repeatable, set `ShareFolderArg.force_async`.\nIf a :field:`ShareFolderLaunch.async_job_id` is returned, you'll need to call :route:`check_share_job_status` until the action completes to get the metadata for the folder.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ShareFolderArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Share Folder"
      }
    }, 
    "/files/save_url/check_job_status": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SaveUrlJobStatus"
            }
          }
        }, 
        "operationId": "FilesSaveUrlCheckJobStatus", 
        "description": "Check the status of a :route:`save_url` job.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Save Url - Check Job Status"
      }
    }, 
    "/paper/docs/users/add": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "items": {
                "$ref": "#/definitions/AddPaperDocUserMemberResult"
              }, 
              "type": "array"
            }
          }
        }, 
        "operationId": "PaperDocsUsersAdd", 
        "description": "Allows an owner or editor to add users to a Paper doc or change their permissions using their email address or Dropbox account ID.\n\nNote: The Doc owner's permissions cannot be changed.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AddPaperDocUser"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Users - Add"
      }
    }, 
    "/files/copy_reference/save": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SaveCopyReferenceError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SaveCopyReferenceResult"
            }
          }
        }, 
        "operationId": "FilesCopyReferenceSave", 
        "description": "Save a copy reference returned by :route:`copy_reference/get` to the user's Dropbox.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/SaveCopyReferenceArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Copy Reference - Save"
      }
    }, 
    "/sharing/add_file_member": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/AddFileMemberError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "items": {
                "$ref": "#/definitions/FileMemberActionResult"
              }, 
              "type": "array"
            }
          }
        }, 
        "operationId": "SharingAddFileMember", 
        "description": "Adds specified members to a file.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AddFileMemberArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Add File Member"
      }
    }, 
    "/sharing/list_folders/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFoldersContinueError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFoldersResult"
            }
          }
        }, 
        "operationId": "SharingListFoldersContinue", 
        "description": "Once a cursor has been retrieved from :route:`list_folders`, use this to paginate through all shared folders. The cursor must come from a previous call to :route:`list_folders` or :route:`list_folders/continue`.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFoldersContinueArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List Folders - Continue"
      }
    }, 
    "/files/alpha/upload": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UploadErrorWithProperties"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMetadata"
            }
          }
        }, 
        "operationId": "FilesAlphaUpload", 
        "description": "Create a new file with the contents provided in the request. Note that this endpoint is part of the properties API alpha and is slightly different from :route:`upload`.\nDo not use this to upload a file larger than 150 MB. Instead, create an upload session with :route:`upload_session/start`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CommitInfoWithProperties"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Alpha - Upload"
      }
    }, 
    "/files/list_folder/longpoll": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFolderLongpollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFolderLongpollResult"
            }
          }
        }, 
        "operationId": "FilesListFolderLongpoll", 
        "description": "A longpoll endpoint to wait for changes on an account. In conjunction with :route:`list_folder/continue`, this call gives you a low-latency way to monitor an account for file changes. The connection will block until there are changes available or a timeout occurs. This endpoint is useful mostly for client-side apps. If you're looking for server-side notifications, check out our :link:`webhooks documentation https://www.dropbox.com/developers/reference/webhooks`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFolderLongpollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - List Folder - Longpoll"
      }
    }, 
    "/file_properties/templates/remove_for_user": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesRemoveForUser", 
        "description": "Permanently removes the specified template created from :route:`templates/add_for_user`. All properties associated with the template will also be removed. This action cannot be undone.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RemoveTemplateArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - Remove For User"
      }
    }, 
    "/files/get_temporary_link": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetTemporaryLinkError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/GetTemporaryLinkResult"
            }
          }
        }, 
        "operationId": "FilesGetTemporaryLink", 
        "description": "Get a temporary link to stream content of a file. This link will expire in four hours and afterwards you will get 410 Gone. Content-Type of the link is determined automatically by the file's mime type.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetTemporaryLinkArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Get Temporary Link"
      }
    }, 
    "/sharing/list_folder_members/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFolderMembersContinueError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedFolderMembers"
            }
          }
        }, 
        "operationId": "SharingListFolderMembersContinue", 
        "description": "Once a cursor has been retrieved from :route:`list_folder_members`, use this to paginate through all shared folder members.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFolderMembersContinueArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List Folder Members - Continue"
      }
    }, 
    "/file_properties/templates/add_for_user": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ModifyTemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/AddTemplateResult"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesAddForUser", 
        "description": "Add a template associated with a user. See :route:`properties/add` to add properties to a file. This endpoint can't be called on a team member or admin's behalf.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AddTemplateArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - Add For User"
      }
    }, 
    "/files/upload_session/finish_batch": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/UploadSessionFinishBatchLaunch"
            }
          }
        }, 
        "operationId": "FilesUploadSessionFinishBatch", 
        "description": "This route helps you commit many files at once into a user's Dropbox. Use :route:`upload_session/start` and :route:`upload_session/append_v2` to upload file contents. We recommend uploading many files in parallel to increase throughput. Once the file contents have been uploaded, rather than calling :route:`upload_session/finish`, use this route to finish all your upload sessions in a single request.\n:field:`UploadSessionStartArg.close` or :field:`UploadSessionAppendArg.close` needs to be true for the last :route:`upload_session/start` or :route:`upload_session/append_v2` call. The maximum size of a file one can upload to an upload session is 350 GB.\nThis route will return a job_id immediately and do the async commit job in background. Use :route:`upload_session/finish_batch/check` to check the job status.\nFor the same account, this route should be executed serially. That means you should not start the next job before current job finishes. We allow up to 1000 entries in a single request.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UploadSessionFinishBatchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Upload Session - Finish Batch"
      }
    }, 
    "/files/upload_session/append_v2": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UploadSessionLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "FilesUploadSessionAppendV2", 
        "description": "Append more data to an upload session.\nWhen the parameter close is set, this call will close the session.\nA single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UploadSessionAppendArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Upload Session - Append V2"
      }
    }, 
    "/files/create_folder_v2": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/CreateFolderError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/CreateFolderResult"
            }
          }
        }, 
        "operationId": "FilesCreateFolderV2", 
        "description": "Create a folder at a given path.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CreateFolderArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Create Folder V2"
      }
    }, 
    "/files/copy_reference/get": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetCopyReferenceError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/GetCopyReferenceResult"
            }
          }
        }, 
        "operationId": "FilesCopyReferenceGet", 
        "description": "Get a copy reference to a file or folder. This reference string can be used to save that file or folder to another user's Dropbox by passing it to :route:`copy_reference/save`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetCopyReferenceArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Copy Reference - Get"
      }
    }, 
    "/paper/docs/users/list/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListUsersCursorError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListUsersOnPaperDocResponse"
            }
          }
        }, 
        "operationId": "PaperDocsUsersListContinue", 
        "description": "Once a cursor has been retrieved from :route:`docs/users/list`, use this to paginate through all users on the Paper doc.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListUsersOnPaperDocContinueArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Users - List - Continue"
      }
    }, 
    "/file_properties/properties/search/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PropertiesSearchContinueError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/PropertiesSearchResult"
            }
          }
        }, 
        "operationId": "FilePropertiesPropertiesSearchContinue", 
        "description": "Once a cursor has been retrieved from :route:`properties/search`, use this to paginate through all search results.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PropertiesSearchContinueArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Properties - Search - Continue"
      }
    }, 
    "/files/list_folder": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFolderError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFolderResult"
            }
          }
        }, 
        "operationId": "FilesListFolder", 
        "description": "Starts returning the contents of a folder. If the result's :field:`ListFolderResult.has_more` field is :val:`true`, call :route:`list_folder/continue` with the returned :field:`ListFolderResult.cursor` to retrieve more entries.\nIf you're using :field:`ListFolderArg.recursive` set to :val:`true` to keep a local cache of the contents of a Dropbox account, iterate through each entry in order and process them as follows to keep your local state in sync:\nFor each :type:`FileMetadata`, store the new entry at the given path in your local state. If the required parent folders don't exist yet, create them. If there's already something else at the given path, replace it and remove all its children.\nFor each :type:`FolderMetadata`, store the new entry at the given path in your local state. If the required parent folders don't exist yet, create them. If there's already something else at the given path, replace it but leave the children as they are. Check the new entry's :field:`FolderSharingInfo.read_only` and set all its children's read-only statuses to match.\nFor each :type:`DeletedMetadata`, if your local state has something at the given path, remove it and all its children. If there's nothing at the given path, ignore this entry.\nNote: :type:`auth.RateLimitError` may be returned if multiple :route:`list_folder` or :route:`list_folder/continue` calls with same parameters are made simultaneously by same API app for same user. If your app implements retry logic, please hold off the retry until the previous request finishes.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFolderArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - List Folder"
      }
    }, 
    "/files/upload_session/finish": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UploadSessionFinishError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMetadata"
            }
          }
        }, 
        "operationId": "FilesUploadSessionFinish", 
        "description": "Finish an upload session and save the uploaded data to the given file path.\nA single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UploadSessionFinishArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Upload Session - Finish"
      }
    }, 
    "/sharing/get_shared_links": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetSharedLinksError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/GetSharedLinksResult"
            }
          }
        }, 
        "operationId": "SharingGetSharedLinks", 
        "description": "Returns a list of :type:`LinkMetadata` objects for this user, including collection links.\nIf no path is given, returns a list of all shared links for the current user, including collection links, up to a maximum of 1000 links.\nIf a non-empty path is given, returns a list of all shared links that allow access to the given path.  Collection links are never returned in this case.\nNote that the url field in the response is never the shortened URL.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetSharedLinksArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Get Shared Links"
      }
    }, 
    "/files/move_batch": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/RelocationBatchLaunch"
            }
          }
        }, 
        "operationId": "FilesMoveBatch", 
        "description": "Move multiple files or folders to different locations at once in the user's Dropbox.\nThis route is 'all or nothing', which means if one entry fails, the whole transaction will abort.\nThis route will return job ID immediately and do the async moving job in background. Please use :route:`move_batch/check` to check the job status.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RelocationBatchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Move Batch"
      }
    }, 
    "/files/list_folder/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFolderContinueError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFolderResult"
            }
          }
        }, 
        "operationId": "FilesListFolderContinue", 
        "description": "Once a cursor has been retrieved from :route:`list_folder`, use this to paginate through all files and retrieve updates to the folder, following the same rules as documented for :route:`list_folder`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFolderContinueArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - List Folder - Continue"
      }
    }, 
    "/paper/docs/permanently_delete": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "PaperDocsPermanentlyDelete", 
        "description": "Permanently deletes the given Paper doc. This operation is final as the doc cannot be recovered.\n\nNote: This action can be performed only by the doc owner.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RefPaperDoc"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Permanently Delete"
      }
    }, 
    "/users/get_space_usage": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SpaceUsage"
            }
          }
        }, 
        "operationId": "UsersGetSpaceUsage", 
        "description": "Get the space usage information for the current user's account.", 
        "parameters": [
          {
            "schema": {
              "type": "null"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Users - Get Space Usage"
      }
    }, 
    "/file_properties/properties/add": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/AddPropertiesError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "FilePropertiesPropertiesAdd", 
        "description": "Add property groups to a Dropbox file. See :route:`templates/add_for_user` or :route:`templates/add_for_team` to create new templates.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AddPropertiesArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Properties - Add"
      }
    }, 
    "/sharing/add_folder_member": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/AddFolderMemberError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "SharingAddFolderMember", 
        "description": "Allows an owner or editor (if the ACL update policy allows) of a shared folder to add another member.\nFor the new member to get access to all the functionality for this folder, you will need to call :route:`mount_folder` on their behalf.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AddFolderMemberArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Add Folder Member"
      }
    }, 
    "/sharing/list_shared_links": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListSharedLinksError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListSharedLinksResult"
            }
          }
        }, 
        "operationId": "SharingListSharedLinks", 
        "description": "List shared links of this user.\nIf no path is given, returns a list of all shared links for the current user.\nIf a non-empty path is given, returns a list of all shared links that allow access to the given path - direct links to the given path and links to parent folders of the given path. Links to parent folders can be suppressed by setting direct_only to true.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListSharedLinksArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List Shared Links"
      }
    }, 
    "/files/upload": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UploadError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMetadata"
            }
          }
        }, 
        "operationId": "FilesUpload", 
        "description": "Create a new file with the contents provided in the request.\nDo not use this to upload a file larger than 150 MB. Instead, create an upload session with :route:`upload_session/start`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CommitInfo"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Upload"
      }
    }, 
    "/file_properties/templates/update_for_user": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ModifyTemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/UpdateTemplateResult"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesUpdateForUser", 
        "description": "Update a template associated with a user. This route can update the template name, the template description and add optional properties to templates. This endpoint can't be called on a team member or admin's behalf.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpdateTemplateArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - Update For User"
      }
    }, 
    "/sharing/list_received_files/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFilesContinueError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFilesResult"
            }
          }
        }, 
        "operationId": "SharingListReceivedFilesContinue", 
        "description": "Get more results with a cursor from :route:`list_received_files`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFilesContinueArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List Received Files - Continue"
      }
    }, 
    "/files/download_zip": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DownloadZipError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/DownloadZipResult"
            }
          }
        }, 
        "operationId": "FilesDownloadZip", 
        "description": "Download a folder from the user's Dropbox, as a zip file. The folder must be less than 1 GB in size and have fewer than 10,000 total files. The input cannot be a single file.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DownloadZipArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Download Zip"
      }
    }, 
    "/sharing/change_file_member_access": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/FileMemberActionError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMemberActionResult"
            }
          }
        }, 
        "operationId": "SharingChangeFileMemberAccess", 
        "description": "Identical to update_file_member but with less information returned.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ChangeFileMemberAccessArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Change File Member Access"
      }
    }, 
    "/file_properties/templates/add_for_team": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ModifyTemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/AddTemplateResult"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesAddForTeam", 
        "description": "Add a template associated with a team. See :route:`properties/add` to add properties to a file or folder.\nNote: this endpoint will create team-owned templates.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AddTemplateArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - Add For Team"
      }
    }, 
    "/sharing/modify_shared_link_settings": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ModifySharedLinkSettingsError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedLinkMetadata"
            }
          }
        }, 
        "operationId": "SharingModifySharedLinkSettings", 
        "description": "Modify the shared link's settings.\nIf the requested visibility conflict with the shared links policy of the team or the shared folder (in case the linked file is part of a shared folder) then the :field:`LinkPermissions.resolved_visibility` of the returned :type:`SharedLinkMetadata` will reflect the actual visibility of the shared link and the :field:`LinkPermissions.requested_visibility` will reflect the requested visibility.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ModifySharedLinkSettingsArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Modify Shared Link Settings"
      }
    }, 
    "/sharing/create_shared_link": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/CreateSharedLinkError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/PathLinkMetadata"
            }
          }
        }, 
        "operationId": "SharingCreateSharedLink", 
        "description": "Create a shared link.\nIf a shared link already exists for the given path, that link is returned.\nNote that in the returned :type:`PathLinkMetadata`, the :field:`PathLinkMetadata.url` field is the shortened URL if :field:`CreateSharedLinkArg.short_url` argument is set to :val:`true`.\nPreviously, it was technically possible to break a shared link by moving or renaming the corresponding file or folder. In the future, this will no longer be the case, so your app shouldn't rely on this behavior. Instead, if your app needs to revoke a shared link, use :route:`revoke_shared_link`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CreateSharedLinkArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Create Shared Link"
      }
    }, 
    "/sharing/remove_file_member": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RemoveFileMemberError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMemberActionIndividualResult"
            }
          }
        }, 
        "operationId": "SharingRemoveFileMember", 
        "description": "Identical to remove_file_member_2 but with less information returned.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RemoveFileMemberArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Remove File Member"
      }
    }, 
    "/auth/token/revoke": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "AuthTokenRevoke", 
        "description": "Disables the access token used to authenticate the call.", 
        "parameters": [
          {
            "schema": {
              "type": "null"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Auth - Token - Revoke"
      }
    }, 
    "/files/copy": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RelocationError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/Metadata"
            }
          }
        }, 
        "operationId": "FilesCopy", 
        "description": "Copy a file or folder to a different location in the user's Dropbox.\nIf the source path is a folder all its contents will be copied.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RelocationArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Copy"
      }
    }, 
    "/sharing/get_shared_link_metadata": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SharedLinkError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedLinkMetadata"
            }
          }
        }, 
        "operationId": "SharingGetSharedLinkMetadata", 
        "description": "Get the shared link's metadata.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetSharedLinkMetadataArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Get Shared Link Metadata"
      }
    }, 
    "/file_properties/properties/overwrite": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/InvalidPropertyGroupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "FilePropertiesPropertiesOverwrite", 
        "description": "Overwrite property groups associated with a file. This endpoint should be used instead of :route:`properties/update` when property groups are being updated via a \"snapshot\" instead of via a \"delta\". In other words, this endpoint will delete all omitted fields from a property group, whereas :route:`properties/update` will only delete fields that are explicitly marked for deletion.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/OverwritePropertyGroupArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Properties - Overwrite"
      }
    }, 
    "/files/permanently_delete": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DeleteError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "FilesPermanentlyDelete", 
        "description": "Permanently delete the file or folder at a given path (see https://www.dropbox.com/en/help/40).\nNote: This endpoint is only available for Dropbox Business apps.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DeleteArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Permanently Delete"
      }
    }, 
    "/sharing/unshare_folder": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UnshareFolderError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/LaunchEmptyResult"
            }
          }
        }, 
        "operationId": "SharingUnshareFolder", 
        "description": "Allows a shared folder owner to unshare the folder.\nYou'll need to call :route:`check_job_status` to determine if the action has completed successfully.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UnshareFolderArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Unshare Folder"
      }
    }, 
    "/sharing/list_mountable_folders/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFoldersContinueError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFoldersResult"
            }
          }
        }, 
        "operationId": "SharingListMountableFoldersContinue", 
        "description": "Once a cursor has been retrieved from :route:`list_mountable_folders`, use this to paginate through all mountable shared folders. The cursor must come from a previous call to :route:`list_mountable_folders` or :route:`list_mountable_folders/continue`.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFoldersContinueArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List Mountable Folders - Continue"
      }
    }, 
    "/file_properties/templates/get_for_team": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/GetTemplateResult"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesGetForTeam", 
        "description": "Get the schema for a specified template.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetTemplateArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - Get For Team"
      }
    }, 
    "/sharing/relinquish_folder_membership": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RelinquishFolderMembershipError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/LaunchEmptyResult"
            }
          }
        }, 
        "operationId": "SharingRelinquishFolderMembership", 
        "description": "The current user relinquishes their membership in the designated shared folder and will no longer have access to the folder.  A folder owner cannot relinquish membership in their own folder.\nThis will run synchronously if leave_a_copy is false, and asynchronously if leave_a_copy is true. Apps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RelinquishFolderMembershipArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Relinquish Folder Membership"
      }
    }, 
    "/files/download": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DownloadError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMetadata"
            }
          }
        }, 
        "operationId": "FilesDownload", 
        "description": "Download a file from a user's Dropbox.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DownloadArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Download"
      }
    }, 
    "/files/search": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SearchError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SearchResult"
            }
          }
        }, 
        "operationId": "FilesSearch", 
        "description": "Searches for files and folders.\nNote: Recent changes may not immediately be reflected in search results due to a short delay in indexing.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/SearchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Search"
      }
    }, 
    "/sharing/get_file_metadata": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetFileMetadataError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedFileMetadata"
            }
          }
        }, 
        "operationId": "SharingGetFileMetadata", 
        "description": "Returns shared file metadata.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetFileMetadataArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Get File Metadata"
      }
    }, 
    "/sharing/list_mountable_folders": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFoldersResult"
            }
          }
        }, 
        "operationId": "SharingListMountableFolders", 
        "description": "Return the list of all shared folders the current user can mount or unmount.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFoldersArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List Mountable Folders"
      }
    }, 
    "/file_properties/templates/list_for_team": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListTemplateResult"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesListForTeam", 
        "description": "Get the template identifiers for a team. To get the schema of each template use :route:`templates/get_for_team`.", 
        "parameters": [
          {
            "schema": {
              "type": "null"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - List For Team"
      }
    }, 
    "/file_properties/properties/remove": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RemovePropertiesError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "FilePropertiesPropertiesRemove", 
        "description": "Permanently removes the specified property group from the file. To remove specific property field key value pairs, see :route:`properties/update`. To update a template, see :route:`templates/update_for_user` or :route:`templates/update_for_team`. To remove a template, see :route:`templates/remove_for_user` or :route:`templates/remove_for_team`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RemovePropertiesArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Properties - Remove"
      }
    }, 
    "/files/create_folder": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/CreateFolderError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FolderMetadata"
            }
          }
        }, 
        "operationId": "FilesCreateFolder", 
        "description": "Create a folder at a given path.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CreateFolderArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Create Folder"
      }
    }, 
    "/file_requests/list": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFileRequestsError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFileRequestsResult"
            }
          }
        }, 
        "operationId": "FileRequestsList", 
        "description": "Returns a list of file requests owned by this user. For apps with the app folder permission, this will only return file requests with destinations in the app folder.", 
        "parameters": [
          {
            "schema": {
              "type": "null"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Requests - List"
      }
    }, 
    "/paper/docs/archive": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "PaperDocsArchive", 
        "description": "Marks the given Paper doc as archived.\nNote: This action can be performed or undone by anyone with edit permissions to the doc.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RefPaperDoc"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Archive"
      }
    }, 
    "/users/get_account_batch": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetAccountBatchError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "items": {
                "$ref": "#/definitions/BasicAccount"
              }, 
              "type": "array"
            }
          }
        }, 
        "operationId": "UsersGetAccountBatch", 
        "description": "Get information about multiple user accounts.  At most 300 accounts may be queried per request.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetAccountBatchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Users - Get Account Batch"
      }
    }, 
    "/file_requests/create": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/CreateFileRequestError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileRequest"
            }
          }
        }, 
        "operationId": "FileRequestsCreate", 
        "description": "Creates a file request for this user.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CreateFileRequestArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Requests - Create"
      }
    }, 
    "/sharing/list_file_members": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFileMembersError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedFileMembers"
            }
          }
        }, 
        "operationId": "SharingListFileMembers", 
        "description": "Use to obtain the members who have been invited to a file, both inherited and uninherited members.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFileMembersArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List File Members"
      }
    }, 
    "/file_properties/templates/update_for_team": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ModifyTemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/UpdateTemplateResult"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesUpdateForTeam", 
        "description": "Update a template associated with a team. This route can update the template name, the template description and add optional properties to templates.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpdateTemplateArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - Update For Team"
      }
    }, 
    "/sharing/list_file_members/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListFileMembersContinueError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedFileMembers"
            }
          }
        }, 
        "operationId": "SharingListFileMembersContinue", 
        "description": "Once a cursor has been retrieved from :route:`list_file_members` or :route:`list_file_members/batch`, use this to paginate through all shared file members.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFileMembersContinueArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List File Members - Continue"
      }
    }, 
    "/paper/docs/update": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PaperDocUpdateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/PaperDocCreateUpdateResult"
            }
          }
        }, 
        "operationId": "PaperDocsUpdate", 
        "description": "Updates an existing Paper doc with the provided content.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PaperDocUpdateArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Update"
      }
    }, 
    "/auth/token/from_oauth1": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TokenFromOAuth1Error"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/TokenFromOAuth1Result"
            }
          }
        }, 
        "operationId": "AuthTokenFromOauth1", 
        "description": "Creates an OAuth 2.0 access token from the supplied OAuth 1.0 access token.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/TokenFromOAuth1Arg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Auth - Token - From Oauth1"
      }
    }, 
    "/files/properties/overwrite": {
      "post": {
        "operationId": "FilesPropertiesOverwrite", 
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/InvalidPropertyGroupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/OverwritePropertyGroupArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Properties - Overwrite"
      }
    }, 
    "/file_requests/get": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetFileRequestError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileRequest"
            }
          }
        }, 
        "operationId": "FileRequestsGet", 
        "description": "Returns the specified file request.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetFileRequestArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Requests - Get"
      }
    }, 
    "/paper/docs/list/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListDocsCursorError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListPaperDocsResponse"
            }
          }
        }, 
        "operationId": "PaperDocsListContinue", 
        "description": "Once a cursor has been retrieved from :route:`docs/list`, use this to paginate through all Paper doc.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListPaperDocsContinueArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - List - Continue"
      }
    }, 
    "/files/get_thumbnail": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ThumbnailError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMetadata"
            }
          }
        }, 
        "operationId": "FilesGetThumbnail", 
        "description": "Get a thumbnail for an image.\nThis method currently supports files with the following file extensions: jpg, jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB in size won't be converted to a thumbnail.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ThumbnailArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Get Thumbnail"
      }
    }, 
    "/sharing/update_folder_policy": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UpdateFolderPolicyError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedFolderMetadata"
            }
          }
        }, 
        "operationId": "SharingUpdateFolderPolicy", 
        "description": "Update the sharing policies for a shared folder.\nUser must have :field:`AccessLevel.owner` access to the shared folder to update its policies.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UpdateFolderPolicyArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Update Folder Policy"
      }
    }, 
    "/sharing/set_access_inheritance": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SetAccessInheritanceError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ShareFolderLaunch"
            }
          }
        }, 
        "operationId": "SharingSetAccessInheritance", 
        "description": "Change the inheritance policy of an existing Shared Folder. Only permitted for shared folders in a shared team root.\nIf a :field:`ShareFolderLaunch.async_job_id` is returned, you'll need to call :route:`check_share_job_status` until the action completes to get the metadata for the folder.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/SetAccessInheritanceArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Set Access Inheritance"
      }
    }, 
    "/files/save_url": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SaveUrlError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SaveUrlResult"
            }
          }
        }, 
        "operationId": "FilesSaveUrl", 
        "description": "Save a specified URL into a file in user's Dropbox. If the given path already exists, the file will be renamed to avoid the conflict (e.g. myfile (1).txt).", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/SaveUrlArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Save Url"
      }
    }, 
    "/files/alpha/get_metadata": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/AlphaGetMetadataError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/Metadata"
            }
          }
        }, 
        "operationId": "FilesAlphaGetMetadata", 
        "description": "Returns the metadata for a file or folder. This is an alpha endpoint compatible with the properties API.\nNote: Metadata for the root folder is unsupported.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/AlphaGetMetadataArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Alpha - Get Metadata"
      }
    }, 
    "/sharing/remove_file_member_2": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RemoveFileMemberError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMemberRemoveActionResult"
            }
          }
        }, 
        "operationId": "SharingRemoveFileMember2", 
        "description": "Removes a specified member from the file.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RemoveFileMemberArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Remove File Member 2"
      }
    }, 
    "/files/copy_v2": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RelocationError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/RelocationResult"
            }
          }
        }, 
        "operationId": "FilesCopyV2", 
        "description": "Copy a file or folder to a different location in the user's Dropbox.\nIf the source path is a folder all its contents will be copied.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RelocationArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Copy V2"
      }
    }, 
    "/files/upload_session/start": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/UploadSessionStartResult"
            }
          }
        }, 
        "operationId": "FilesUploadSessionStart", 
        "description": "Upload sessions allow you to upload a single file in one or more requests, for example where the size of the file is greater than 150 MB.  This call starts a new upload session with the given data. You can then use :route:`upload_session/append_v2` to add more data and :route:`upload_session/finish` to save all the data to a file in Dropbox.\nA single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB.\nAn upload session can be used for a maximum of 48 hours. Attempting to use an :field:`UploadSessionStartResult.session_id` with :route:`upload_session/append_v2` or :route:`upload_session/finish` more than 48 hours after its creation will return a :field:`UploadSessionLookupError.not_found`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UploadSessionStartArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Upload Session - Start"
      }
    }, 
    "/file_properties/templates/list_for_user": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListTemplateResult"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesListForUser", 
        "description": "Get the template identifiers for a team. To get the schema of each template use :route:`templates/get_for_user`. This endpoint can't be called on a team member or admin's behalf.", 
        "parameters": [
          {
            "schema": {
              "type": "null"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - List For User"
      }
    }, 
    "/files/create_folder_batch": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/CreateFolderBatchLaunch"
            }
          }
        }, 
        "operationId": "FilesCreateFolderBatch", 
        "description": "Create multiple folders at once.\nThis route is asynchronous for large batches, which returns a job ID immediately and runs the create folder batch asynchronously. Otherwise, creates the folders and returns the result synchronously for smaller inputs. You can force asynchronous behaviour by using the :field:`CreateFolderBatchArg.force_async` flag.  Use :route:`create_folder_batch/check` to check the job status.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/CreateFolderBatchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Create Folder Batch"
      }
    }, 
    "/users/get_account": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetAccountError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/BasicAccount"
            }
          }
        }, 
        "operationId": "UsersGetAccount", 
        "description": "Get information about a user's account.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetAccountArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Users - Get Account"
      }
    }, 
    "/files/move_v2": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/RelocationError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/RelocationResult"
            }
          }
        }, 
        "operationId": "FilesMoveV2", 
        "description": "Move a file or folder to a different location in the user's Dropbox.\nIf the source path is a folder all its contents will be moved.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RelocationArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Move V2"
      }
    }, 
    "/paper/docs/folder_users/list/continue": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListUsersCursorError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListUsersOnFolderResponse"
            }
          }
        }, 
        "operationId": "PaperDocsFolderUsersListContinue", 
        "description": "Once a cursor has been retrieved from :route:`docs/folder_users/list`, use this to paginate through all users on the Paper folder.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListUsersOnFolderContinueArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Folder Users - List - Continue"
      }
    }, 
    "/sharing/get_file_metadata/batch": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SharingUserError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "items": {
                "$ref": "#/definitions/GetFileMetadataBatchResult"
              }, 
              "type": "array"
            }
          }
        }, 
        "operationId": "SharingGetFileMetadataBatch", 
        "description": "Returns shared file metadata.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetFileMetadataBatchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Get File Metadata - Batch"
      }
    }, 
    "/paper/docs/users/remove": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "PaperDocsUsersRemove", 
        "description": "Allows an owner or editor to remove users from a Paper doc using their email address or Dropbox account ID.\n\nNote: Doc owner cannot be removed.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/RemovePaperDocUser"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Users - Remove"
      }
    }, 
    "/paper/docs/folder_users/list": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListUsersOnFolderResponse"
            }
          }
        }, 
        "operationId": "PaperDocsFolderUsersList", 
        "description": "Lists the users who are explicitly invited to the Paper folder in which the Paper doc is contained. For private folders all users (including owner) shared on the folder are listed and for team folders all non-team users shared on the folder are returned.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListUsersOnFolderArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Folder Users - List"
      }
    }, 
    "/files/upload_session/append": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/UploadSessionLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "FilesUploadSessionAppend", 
        "description": "Append more data to an upload session.\nA single request should not upload more than 150 MB. The maximum size of a file one can upload to an upload session is 350 GB.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/UploadSessionCursor"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Upload Session - Append"
      }
    }, 
    "/sharing/list_folders": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListFoldersResult"
            }
          }
        }, 
        "operationId": "SharingListFolders", 
        "description": "Return the list of all shared folders the current user has access to.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFoldersArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List Folders"
      }
    }, 
    "/files/get_metadata": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetMetadataError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/Metadata"
            }
          }
        }, 
        "operationId": "FilesGetMetadata", 
        "description": "Returns the metadata for a file or folder.\nNote: Metadata for the root folder is unsupported.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetMetadataArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Get Metadata"
      }
    }, 
    "/sharing/list_file_members/batch": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/SharingUserError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "items": {
                "$ref": "#/definitions/ListFileMembersBatchResult"
              }, 
              "type": "array"
            }
          }
        }, 
        "operationId": "SharingListFileMembersBatch", 
        "description": "Get members of multiple files at once. The arguments to this route are more limited, and the limit on query result size per file is more strict. To customize the results more, use the individual file endpoint.\nInherited users and groups are not included in the result, and permissions are not returned for this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListFileMembersBatchArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - List File Members - Batch"
      }
    }, 
    "/sharing/transfer_folder": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TransferFolderError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "type": "null"
            }
          }
        }, 
        "operationId": "SharingTransferFolder", 
        "description": "Transfer ownership of a shared folder to a member of the shared folder.\nUser must have :field:`AccessLevel.owner` access to the shared folder to perform a transfer.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/TransferFolderArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Transfer Folder"
      }
    }, 
    "/file_properties/templates/get_for_user": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/GetTemplateResult"
            }
          }
        }, 
        "operationId": "FilePropertiesTemplatesGetForUser", 
        "description": "Get the schema for a specified template. This endpoint can't be called on a team member or admin's behalf.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetTemplateArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "File Properties - Templates - Get For User"
      }
    }, 
    "/files/list_revisions": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/ListRevisionsError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListRevisionsResult"
            }
          }
        }, 
        "operationId": "FilesListRevisions", 
        "description": "Returns revisions for files based on a file path or a file id. The file path or file id is identified from the latest file entry at the given file path or id. This end point allows your app to query either by file path or file id by setting the mode parameter appropriately.\nIn the :field:`ListRevisionsMode.path` (default) mode, all revisions at the same file path as the latest file entry are returned. If revisions with the same file id are desired, then mode must be set to :field:`ListRevisionsMode.id`. The :field:`ListRevisionsMode.id` mode is useful to retrieve revisions for a given file across moves or renames.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListRevisionsArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - List Revisions"
      }
    }, 
    "/files/get_preview": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PreviewError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/FileMetadata"
            }
          }
        }, 
        "operationId": "FilesGetPreview", 
        "description": "Get a preview for a file.\nCurrently, PDF previews are generated for files with the following extensions: .ai, .doc, .docm, .docx, .eps, .odp, .odt, .pps, .ppsm, .ppsx, .ppt, .pptm, .pptx, .rtf.\nHTML previews are generated for files with the following extensions: .csv, .ods, .xls, .xlsm, .xlsx.\nOther formats will return an unsupported extension error.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PreviewArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Get Preview"
      }
    }, 
    "/files/properties/template/list": {
      "post": {
        "operationId": "FilesPropertiesTemplateList", 
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/TemplateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListTemplateResult"
            }
          }
        }, 
        "parameters": [
          {
            "schema": {
              "type": "null"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Properties - Template - List"
      }
    }, 
    "/paper/docs/create": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PaperDocCreateError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/PaperDocCreateUpdateResult"
            }
          }
        }, 
        "operationId": "PaperDocsCreate", 
        "description": "Creates a new Paper doc with the provided content.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PaperDocCreateArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Create"
      }
    }, 
    "/paper/docs/list": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "type": "null"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/ListPaperDocsResponse"
            }
          }
        }, 
        "operationId": "PaperDocsList", 
        "description": "Return the list of all Paper docs according to the argument specifications. To iterate over through the full pagination, pass the cursor to :route:`docs/list/continue`.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/ListPaperDocsArgs"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - List"
      }
    }, 
    "/sharing/get_shared_link_file": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/GetSharedLinkFileError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/SharedLinkMetadata"
            }
          }
        }, 
        "operationId": "SharingGetSharedLinkFile", 
        "description": "Download the shared link's file from a user's Dropbox.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/GetSharedLinkMetadataArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Get Shared Link File"
      }
    }, 
    "/paper/docs/download": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DocLookupError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/PaperDocExportResult"
            }
          }
        }, 
        "operationId": "PaperDocsDownload", 
        "description": "Exports and downloads Paper doc either as HTML or markdown.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PaperDocExport"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Paper - Docs - Download"
      }
    }, 
    "/files/delete_batch/check": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/DeleteBatchJobStatus"
            }
          }
        }, 
        "operationId": "FilesDeleteBatchCheck", 
        "description": "Returns the status of an asynchronous job for :route:`delete_batch`. If success, it returns list of result for each entry.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Delete Batch - Check"
      }
    }, 
    "/files/delete_v2": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/DeleteError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/DeleteResult"
            }
          }
        }, 
        "operationId": "FilesDeleteV2", 
        "description": "Delete the file or folder at a given path.\nIf the path is a folder, all its contents will be deleted too.\nA successful response indicates that the file or folder was deleted. The returned metadata will be the corresponding :type:`FileMetadata` or :type:`FolderMetadata` for the item at time of deletion, and not a :type:`DeletedMetadata` object.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/DeleteArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Files - Delete V2"
      }
    }, 
    "/sharing/check_job_status": {
      "post": {
        "responses": {
          "default": {
            "description": "Error", 
            "schema": {
              "$ref": "#/definitions/PollError"
            }
          }, 
          "200": {
            "description": "Success", 
            "schema": {
              "$ref": "#/definitions/JobStatus"
            }
          }
        }, 
        "operationId": "SharingCheckJobStatus", 
        "description": "Returns the status of an asynchronous job.\nApps must have full Dropbox access to use this endpoint.", 
        "parameters": [
          {
            "schema": {
              "$ref": "#/definitions/PollArg"
            }, 
            "name": "body", 
            "in": "body"
          }
        ], 
        "summary": "Sharing - Check Job Status"
      }
    }
  }, 
  "produces": [
    "application/json"
  ], 
  "basePath": "/2", 
  "host": "api.dropbox.com", 
  "definitions": {
    "PreviewArg": {
      "type": "object", 
      "description": "path: The path of the file to preview.\nrev: Please specify revision in :field:`path` instead.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path of the file to preview."
        }, 
        "rev": {
          "type": "string", 
          "description": "Please specify revision in :field:`path` instead."
        }
      }
    }, 
    "Metadata": {
      "type": "object", 
      "description": "Metadata for a file or folder.\nname: The last component of the path (including extension). This never contains a slash.\npath_lower: The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if the file or folder is not mounted.\npath_display: The cased path to be used for display purposes only. In rare instances the casing will not correctly match the user's filesystem, but this behavior will match the path provided in the Core API v1, and at least the last path component will have the correct casing. Changes to only the casing of paths won't be returned by :route:`list_folder/continue`. This field will be null if the file or folder is not mounted.\nparent_shared_folder_id: Please use :field:`FileSharingInfo.parent_shared_folder_id` or :field:`FolderSharingInfo.parent_shared_folder_id` instead.\n", 
      "properties": {
        "parent_shared_folder_id": {
          "type": "string", 
          "description": "Please use :field:`FileSharingInfo.parent_shared_folder_id` or :field:`FolderSharingInfo.parent_shared_folder_id` instead."
        }, 
        "name": {
          "type": "string", 
          "description": "The last component of the path (including extension). This never contains a slash."
        }, 
        "path_display": {
          "type": "string", 
          "description": "The cased path to be used for display purposes only. In rare instances the casing will not correctly match the user's filesystem, but this behavior will match the path provided in the Core API v1, and at least the last path component will have the correct casing. Changes to only the casing of paths won't be returned by :route:`list_folder/continue`. This field will be null if the file or folder is not mounted."
        }, 
        "path_lower": {
          "type": "string", 
          "description": "The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if the file or folder is not mounted."
        }
      }
    }, 
    "ShareFolderArg": {
      "type": "object", 
      "description": "path: The path to the folder to share. If it does not exist, then a new one is created.\nacl_update_policy: Who can add and remove members of this shared folder.\nforce_async: Whether to force the share to happen asynchronously.\nmember_policy: Who can be a member of this shared folder. Only applicable if the current user is on a team.\nshared_link_policy: The policy to apply to shared links created for content inside this shared folder.  The current user must be on a team to set this policy to :field:`SharedLinkPolicy.members`.\nviewer_info_policy: Who can enable/disable viewer info for this shared folder.\nactions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's :field:`SharedFolderMetadata.permissions` field describing the actions the  authenticated user can perform on the folder.\nlink_settings: Settings on the link for this folder.\n", 
      "properties": {
        "viewer_info_policy": {
          "$ref": "#/definitions/ViewerInfoPolicy"
        }, 
        "force_async": {
          "type": "boolean", 
          "description": "Whether to force the share to happen asynchronously."
        }, 
        "acl_update_policy": {
          "$ref": "#/definitions/AclUpdatePolicy"
        }, 
        "actions": {
          "items": {
            "$ref": "#/definitions/FolderAction"
          }, 
          "type": "array", 
          "description": "A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's :field:`SharedFolderMetadata.permissions` field describing the actions the  authenticated user can perform on the folder."
        }, 
        "shared_link_policy": {
          "$ref": "#/definitions/SharedLinkPolicy"
        }, 
        "path": {
          "type": "string", 
          "description": "The path to the folder to share. If it does not exist, then a new one is created."
        }, 
        "link_settings": {
          "$ref": "#/definitions/LinkSettings"
        }, 
        "member_policy": {
          "$ref": "#/definitions/MemberPolicy"
        }
      }
    }, 
    "UpdateFolderPolicyArg": {
      "type": "object", 
      "description": "If any of the policies are unset, then they retain their current setting.\nshared_folder_id: The ID for the shared folder.\nmember_policy: Who can be a member of this shared folder. Only applicable if the current user is on a team.\nacl_update_policy: Who can add and remove members of this shared folder.\nviewer_info_policy: Who can enable/disable viewer info for this shared folder.\nshared_link_policy: The policy to apply to shared links created for content inside this shared folder. The current user must be on a team to set this policy to :field:`SharedLinkPolicy.members`.\nlink_settings: Settings on the link for this folder.\nactions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's :field:`SharedFolderMetadata.permissions` field describing the actions the  authenticated user can perform on the folder.\n", 
      "properties": {
        "viewer_info_policy": {
          "$ref": "#/definitions/ViewerInfoPolicy"
        }, 
        "acl_update_policy": {
          "$ref": "#/definitions/AclUpdatePolicy"
        }, 
        "actions": {
          "items": {
            "$ref": "#/definitions/FolderAction"
          }, 
          "type": "array", 
          "description": "A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's :field:`SharedFolderMetadata.permissions` field describing the actions the  authenticated user can perform on the folder."
        }, 
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }, 
        "shared_link_policy": {
          "$ref": "#/definitions/SharedLinkPolicy"
        }, 
        "link_settings": {
          "$ref": "#/definitions/LinkSettings"
        }, 
        "member_policy": {
          "$ref": "#/definitions/MemberPolicy"
        }
      }
    }, 
    "LogicalOperator": {
      "type": "object", 
      "description": "Logical operator to join search queries together.\nor_operator: Append a query with an \"or\" operator.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "or_operator", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of LogicalOperator"
        }
      }
    }, 
    "PropertyFieldTemplate": {
      "type": "object", 
      "description": "Defines how a single property field may be structured. Used exclusively by :type:`PropertyGroupTemplate`.\nname: Key of the property field being described. Property field keys can be up to 256 bytes.\ndescription: Description of the property field. Property field descriptions can be up to 1024 bytes.\ntype: Data type of the value of this property field. This type will be enforced upon property creation and modifications.\n", 
      "properties": {
        "type": {
          "$ref": "#/definitions/PropertyType"
        }, 
        "name": {
          "type": "string", 
          "description": "Key of the property field being described. Property field keys can be up to 256 bytes."
        }, 
        "description": {
          "type": "string", 
          "description": "Description of the property field. Property field descriptions can be up to 1024 bytes."
        }
      }
    }, 
    "ModifySharedLinkSettingsArgs": {
      "type": "object", 
      "description": "url: URL of the shared link to change its settings.\nsettings: Set of settings for the shared link.\nremove_expiration: If set to true, removes the expiration of the shared link.\n", 
      "properties": {
        "url": {
          "type": "string", 
          "description": "URL of the shared link to change its settings."
        }, 
        "remove_expiration": {
          "type": "boolean", 
          "description": "If set to true, removes the expiration of the shared link."
        }, 
        "settings": {
          "$ref": "#/definitions/SharedLinkSettings"
        }
      }
    }, 
    "SharedLinkError": {
      "type": "object", 
      "description": "shared_link_not_found: The shared link wasn't found.\nshared_link_access_denied: The caller is not allowed to access this shared link.\nunsupported_link_type: This type of link is not supported.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "shared_link_not_found", 
            "shared_link_access_denied", 
            "unsupported_link_type", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharedLinkError"
        }
      }
    }, 
    "UpdateTemplateArg": {
      "type": "object", 
      "description": "template_id: An identifier for template added by  See :route:`templates/add_for_user` or :route:`templates/add_for_team`.\nname: A display name for the template. template names can be up to 256 bytes.\ndescription: Description for the new template. Template descriptions can be up to 1024 bytes.\nadd_fields: Property field templates to be added to the group template. There can be up to 32 properties in a single template.\n", 
      "properties": {
        "add_fields": {
          "items": {
            "$ref": "#/definitions/PropertyFieldTemplate"
          }, 
          "type": "array", 
          "description": "Property field templates to be added to the group template. There can be up to 32 properties in a single template."
        }, 
        "description": {
          "type": "string", 
          "description": "Description for the new template. Template descriptions can be up to 1024 bytes."
        }, 
        "template_id": {
          "type": "string", 
          "description": "An identifier for template added by  See :route:`templates/add_for_user` or :route:`templates/add_for_team`."
        }, 
        "name": {
          "type": "string", 
          "description": "A display name for the template. template names can be up to 256 bytes."
        }
      }
    }, 
    "UploadSessionStartResult": {
      "type": "object", 
      "description": "session_id: A unique identifier for the upload session. Pass this to :route:`upload_session/append_v2` and :route:`upload_session/finish`.\n", 
      "properties": {
        "session_id": {
          "type": "string", 
          "description": "A unique identifier for the upload session. Pass this to :route:`upload_session/append_v2` and :route:`upload_session/finish`."
        }
      }
    }, 
    "CreateFolderBatchError": {
      "type": "object", 
      "description": "too_many_files: The operation would involve too many files or folders.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "too_many_files", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of CreateFolderBatchError"
        }
      }
    }, 
    "DeleteBatchResultData": {
      "type": "object", 
      "description": "metadata: Metadata of the deleted object.\n", 
      "properties": {
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      }
    }, 
    "FoldersContainingPaperDoc": {
      "type": "object", 
      "description": "Metadata about Paper folders containing the specififed Paper doc.\nfolder_sharing_policy_type: The sharing policy of the folder containing the Paper doc.\nfolders: The folder path. If present the first folder is the root folder.\n", 
      "properties": {
        "folders": {
          "items": {
            "$ref": "#/definitions/Folder"
          }, 
          "type": "array", 
          "description": "The folder path. If present the first folder is the root folder."
        }, 
        "folder_sharing_policy_type": {
          "$ref": "#/definitions/FolderSharingPolicyType"
        }
      }
    }, 
    "GetAccountBatchError": {
      "type": "object", 
      "description": "no_account: The value is an account ID specified in :field:`GetAccountBatchArg.account_ids` that does not exist.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "no_account", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GetAccountBatchError"
        }, 
        "no_account": {
          "type": "string", 
          "description": "The value is an account ID specified in :field:`GetAccountBatchArg.account_ids` that does not exist."
        }
      }
    }, 
    "BasicAccount": {
      "type": "object", 
      "description": "Basic information about any account.\naccount_id: The user's unique Dropbox ID.\nname: Details of a user's name.\nemail: The user's e-mail address. Do not rely on this without checking the :field:`email_verified` field. Even then, it's possible that the user has since lost access to their e-mail.\nemail_verified: Whether the user has verified their e-mail address.\ndisabled: Whether the user has been disabled.\nis_teammate: Whether this user is a teammate of the current user. If this account is the current user's account, then this will be :val:`true`.\nprofile_photo_url: URL for the photo representing the user, if one is set.\nteam_member_id: The user's unique team member id. This field will only be present if the user is part of a team and :field:`is_teammate` is :val:`true`.\n", 
      "properties": {
        "account_id": {
          "type": "string", 
          "description": "The user's unique Dropbox ID."
        }, 
        "is_teammate": {
          "type": "boolean", 
          "description": "Whether this user is a teammate of the current user. If this account is the current user's account, then this will be :val:`true`."
        }, 
        "email_verified": {
          "type": "boolean", 
          "description": "Whether the user has verified their e-mail address."
        }, 
        "team_member_id": {
          "type": "string", 
          "description": "The user's unique team member id. This field will only be present if the user is part of a team and :field:`is_teammate` is :val:`true`."
        }, 
        "disabled": {
          "type": "boolean", 
          "description": "Whether the user has been disabled."
        }, 
        "email": {
          "type": "string", 
          "description": "The user's e-mail address. Do not rely on this without checking the :field:`email_verified` field. Even then, it's possible that the user has since lost access to their e-mail."
        }, 
        "profile_photo_url": {
          "type": "string", 
          "description": "URL for the photo representing the user, if one is set."
        }, 
        "name": {
          "$ref": "#/definitions/Name"
        }
      }
    }, 
    "DeleteBatchResult": {
      "type": "object", 
      "description": "entries: None\n", 
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/DeleteBatchResultEntry"
          }, 
          "type": "array"
        }
      }
    }, 
    "FolderPermission": {
      "type": "object", 
      "description": "Whether the user is allowed to take the action on the shared folder.\naction: The action that the user may wish to take on the folder.\nallow: True if the user is allowed to take the action.\nreason: The reason why the user is denied the permission. Not present if the action is allowed, or if no reason is available.\n", 
      "properties": {
        "action": {
          "$ref": "#/definitions/FolderAction"
        }, 
        "reason": {
          "$ref": "#/definitions/PermissionDeniedReason"
        }, 
        "allow": {
          "type": "boolean", 
          "description": "True if the user is allowed to take the action."
        }
      }
    }, 
    "UploadSessionFinishBatchResultEntry": {
      "type": "object", 
      "description": "success: None\nfailure: None\n", 
      "properties": {
        "failure": {
          "$ref": "#/definitions/UploadSessionFinishError"
        }, 
        ".tag": {
          "enum": [
            "success", 
            "failure"
          ], 
          "type": "string", 
          "title": "Choice of UploadSessionFinishBatchResultEntry"
        }, 
        "success": {
          "$ref": "#/definitions/FileMetadata"
        }
      }
    }, 
    "ExpectedSharedContentLinkMetadata": {
      "type": "object", 
      "description": "The expected metadata of a shared link for a file or folder when a link is first created for the content. Absent if the link already exists.\naudience_options: The audience options that are available for the content. Some audience options may be unavailable. For example, team_only may be unavailable if the content is not owned by a user on a team. The 'default' audience option is always available if the user can modify link settings.\ncurrent_audience: The current audience of the link.\nlink_permissions: A list of permissions for actions you can perform on the link.\npassword_protected: Whether the link is protected by a password.\naccess_level: The access level on the link for this file.\naudience_restricting_shared_folder: The shared folder that prevents the link audience for this link from being more restrictive.\nexpiry: Whether the link has an expiry set on it. A link with an expiry will have its  audience changed to members when the expiry is reached.\n", 
      "properties": {
        "current_audience": {
          "$ref": "#/definitions/LinkAudience"
        }, 
        "password_protected": {
          "type": "boolean", 
          "description": "Whether the link is protected by a password."
        }, 
        "expiry": {
          "type": "string", 
          "description": "Whether the link has an expiry set on it. A link with an expiry will have its  audience changed to members when the expiry is reached."
        }, 
        "access_level": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "audience_restricting_shared_folder": {
          "$ref": "#/definitions/AudienceRestrictingSharedFolder"
        }, 
        "link_permissions": {
          "items": {
            "$ref": "#/definitions/LinkPermission"
          }, 
          "type": "array", 
          "description": "A list of permissions for actions you can perform on the link."
        }, 
        "audience_options": {
          "items": {
            "$ref": "#/definitions/LinkAudience"
          }, 
          "type": "array", 
          "description": "The audience options that are available for the content. Some audience options may be unavailable. For example, team_only may be unavailable if the content is not owned by a user on a team. The 'default' audience option is always available if the user can modify link settings."
        }
      }
    }, 
    "UploadSessionAppendArg": {
      "type": "object", 
      "description": "cursor: Contains the upload session ID and the offset.\nclose: If true, the current session will be closed, at which point you won't be able to call :route:`upload_session/append_v2` anymore with the current session.\n", 
      "properties": {
        "cursor": {
          "$ref": "#/definitions/UploadSessionCursor"
        }, 
        "close": {
          "type": "boolean", 
          "description": "If true, the current session will be closed, at which point you won't be able to call :route:`upload_session/append_v2` anymore with the current session."
        }
      }
    }, 
    "ListUsersOnFolderArgs": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\nlimit: Size limit per batch. The maximum number of users that can be retrieved per batch is 1000. Higher value results in invalid arguments error.\n", 
      "properties": {
        "limit": {
          "type": "number", 
          "description": "Size limit per batch. The maximum number of users that can be retrieved per batch is 1000. Higher value results in invalid arguments error."
        }, 
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }
      }
    }, 
    "ListFileRequestsError": {
      "type": "object", 
      "description": "There was an error retrieving the file requests.\ndisabled_for_team: This user's Dropbox Business team doesn't allow file requests.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "disabled_for_team", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFileRequestsError"
        }
      }
    }, 
    "LaunchResultBase": {
      "type": "object", 
      "description": "Result returned by methods that launch an asynchronous job.\nA method who may either launch an asynchronous job, or complete the request synchronously, can use this union by extending it, and adding a 'complete' field with the type of the synchronous response.\nSee :type:`LaunchEmptyResult` for an example.\nasync_job_id: This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "async_job_id"
          ], 
          "type": "string", 
          "title": "Choice of LaunchResultBase"
        }, 
        "async_job_id": {
          "type": "string", 
          "description": "This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job."
        }
      }
    }, 
    "GetAccountBatchArg": {
      "type": "object", 
      "description": "account_ids: List of user account identifiers.  Should not contain any duplicate account IDs.\n", 
      "properties": {
        "account_ids": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "List of user account identifiers.  Should not contain any duplicate account IDs."
        }
      }
    }, 
    "LookUpPropertiesError": {
      "type": "object", 
      "description": "property_group_not_found: No property group was found.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "property_group_not_found", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of LookUpPropertiesError"
        }
      }
    }, 
    "RemovePaperDocUser": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\nmember: User which should be removed from the Paper doc. Specify only email address or Dropbox account ID.\n", 
      "properties": {
        "member": {
          "$ref": "#/definitions/MemberSelector"
        }, 
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }
      }
    }, 
    "MountFolderArg": {
      "type": "object", 
      "description": "shared_folder_id: The ID of the shared folder to mount.\n", 
      "properties": {
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID of the shared folder to mount."
        }
      }
    }, 
    "ListFoldersResult": {
      "type": "object", 
      "description": "Result for :route:`list_folders` or :route:`list_mountable_folders`, depending on which endpoint was requested.\nUnmounted shared folders can be identified by the absence of :field:`SharedFolderMetadata.path_lower`.\nentries: List of all shared folders the authenticated user has access to.\ncursor: Present if there are additional shared folders that have not been returned yet. Pass the cursor into the corresponding continue endpoint (either :route:`list_folders/continue` or :route:`list_mountable_folders/continue`) to list additional folders.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "Present if there are additional shared folders that have not been returned yet. Pass the cursor into the corresponding continue endpoint (either :route:`list_folders/continue` or :route:`list_mountable_folders/continue`) to list additional folders."
        }, 
        "entries": {
          "items": {
            "$ref": "#/definitions/SharedFolderMetadata"
          }, 
          "type": "array", 
          "description": "List of all shared folders the authenticated user has access to."
        }
      }
    }, 
    "PaperDocPermissionLevel": {
      "type": "object", 
      "description": "edit: User will be granted edit permissions.\nview_and_comment: User will be granted view and comment permissions.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "edit", 
            "view_and_comment", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PaperDocPermissionLevel"
        }
      }
    }, 
    "UnmountFolderArg": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\n", 
      "properties": {
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }
      }
    }, 
    "GetSharedLinkMetadataArg": {
      "type": "object", 
      "description": "url: URL of the shared link.\npath: If the shared link is to a folder, this parameter can be used to retrieve the metadata for a specific file or sub-folder in this folder. A relative path should be used.\nlink_password: If the shared link has a password, this parameter can be used.\n", 
      "properties": {
        "url": {
          "type": "string", 
          "description": "URL of the shared link."
        }, 
        "path": {
          "type": "string", 
          "description": "If the shared link is to a folder, this parameter can be used to retrieve the metadata for a specific file or sub-folder in this folder. A relative path should be used."
        }, 
        "link_password": {
          "type": "string", 
          "description": "If the shared link has a password, this parameter can be used."
        }
      }
    }, 
    "MemberSpaceLimitType": {
      "type": "object", 
      "description": "The type of the space limit imposed on a team member.\noff: The team member does not have imposed space limit.\nalert_only: The team member has soft imposed space limit - the limit is used for display and for notifications.\nstop_sync: The team member has hard imposed space limit - Dropbox file sync will stop after the limit is reached.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "off", 
            "alert_only", 
            "stop_sync", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of MemberSpaceLimitType"
        }
      }
    }, 
    "OverwritePropertyGroupArg": {
      "type": "object", 
      "description": "path: A unique identifier for the file or folder.\nproperty_groups: The property groups \"snapshot\" updates to force apply.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "A unique identifier for the file or folder."
        }, 
        "property_groups": {
          "items": {
            "$ref": "#/definitions/PropertyGroup"
          }, 
          "type": "array", 
          "description": "The property groups \"snapshot\" updates to force apply."
        }
      }
    }, 
    "RemoveFileMemberArg": {
      "type": "object", 
      "description": "Arguments for :route:`remove_file_member_2`.\nfile: File from which to remove members.\nmember: Member to remove from this file. Note that even if an email is specified, it may result in the removal of a user (not an invitee) if the user's main account corresponds to that email address.\n", 
      "properties": {
        "member": {
          "$ref": "#/definitions/MemberSelector"
        }, 
        "file": {
          "type": "string", 
          "description": "File from which to remove members."
        }
      }
    }, 
    "CreateFolderEntryResult": {
      "type": "object", 
      "description": "metadata: Metadata of the created folder.\n", 
      "properties": {
        "metadata": {
          "$ref": "#/definitions/FolderMetadata"
        }
      }
    }, 
    "DeleteResult": {
      "type": "object", 
      "description": "metadata: Metadata of the deleted object.\n", 
      "properties": {
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      }
    }, 
    "TransferFolderError": {
      "type": "object", 
      "description": "access_error: None\ninvalid_dropbox_id: :field:`TransferFolderArg.to_dropbox_id` is invalid.\nnew_owner_not_a_member: The new designated owner is not currently a member of the shared folder.\nnew_owner_unmounted: The new designated owner has not added the folder to their Dropbox.\nnew_owner_email_unverified: The new designated owner's e-mail address is unverified.\nteam_folder: This action cannot be performed on a team shared folder.\nno_permission: The current user does not have permission to perform this action.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "invalid_dropbox_id", 
            "new_owner_not_a_member", 
            "new_owner_unmounted", 
            "new_owner_email_unverified", 
            "team_folder", 
            "no_permission", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of TransferFolderError"
        }
      }
    }, 
    "GetFileRequestArgs": {
      "type": "object", 
      "description": "Arguments for :route:`get`.\nid: The ID of the file request to retrieve.\n", 
      "properties": {
        "id": {
          "type": "string", 
          "description": "The ID of the file request to retrieve."
        }
      }
    }, 
    "ListFileMembersCountResult": {
      "type": "object", 
      "description": "members: A list of members on this file.\nmember_count: The number of members on this file. This does not include inherited members.\n", 
      "properties": {
        "member_count": {
          "type": "number", 
          "description": "The number of members on this file. This does not include inherited members."
        }, 
        "members": {
          "$ref": "#/definitions/SharedFileMembers"
        }
      }
    }, 
    "ThumbnailError": {
      "type": "object", 
      "description": "path: An error occurs when downloading metadata for the image.\nunsupported_extension: The file extension doesn't allow conversion to a thumbnail.\nunsupported_image: The image cannot be converted to a thumbnail.\nconversion_error: An error occurs during thumbnail conversion.\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "unsupported_extension", 
            "unsupported_image", 
            "conversion_error"
          ], 
          "type": "string", 
          "title": "Choice of ThumbnailError"
        }
      }
    }, 
    "DownloadZipArg": {
      "type": "object", 
      "description": "path: The path of the folder to download.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path of the folder to download."
        }
      }
    }, 
    "SharedFolderMembers": {
      "type": "object", 
      "description": "Shared folder user and group membership.\nusers: The list of user members of the shared folder.\ngroups: The list of group members of the shared folder.\ninvitees: The list of invitees to the shared folder.\ncursor: Present if there are additional shared folder members that have not been returned yet. Pass the cursor into :route:`list_folder_members/continue` to list additional members.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "Present if there are additional shared folder members that have not been returned yet. Pass the cursor into :route:`list_folder_members/continue` to list additional members."
        }, 
        "users": {
          "items": {
            "$ref": "#/definitions/UserMembershipInfo"
          }, 
          "type": "array", 
          "description": "The list of user members of the shared folder."
        }, 
        "groups": {
          "items": {
            "$ref": "#/definitions/GroupMembershipInfo"
          }, 
          "type": "array", 
          "description": "The list of group members of the shared folder."
        }, 
        "invitees": {
          "items": {
            "$ref": "#/definitions/InviteeMembershipInfo"
          }, 
          "type": "array", 
          "description": "The list of invitees to the shared folder."
        }
      }
    }, 
    "DownloadZipError": {
      "type": "object", 
      "description": "path: None\ntoo_large: The folder is too large to download.\ntoo_many_files: The folder has too many files to download.\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "too_large", 
            "too_many_files", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of DownloadZipError"
        }
      }
    }, 
    "SharedLinkSettings": {
      "type": "object", 
      "description": "requested_visibility: The requested access for this shared link.\nlink_password: If :field:`requested_visibility` is :field:`RequestedVisibility.password` this is needed to specify the password to access the link.\nexpires: Expiration time of the shared link. By default the link won't expire.\n", 
      "properties": {
        "requested_visibility": {
          "$ref": "#/definitions/RequestedVisibility"
        }, 
        "link_password": {
          "type": "string", 
          "description": "If :field:`requested_visibility` is :field:`RequestedVisibility.password` this is needed to specify the password to access the link."
        }, 
        "expires": {
          "type": "string", 
          "description": "Expiration time of the shared link. By default the link won't expire."
        }
      }
    }, 
    "RevokeSharedLinkArg": {
      "type": "object", 
      "description": "url: URL of the shared link.\n", 
      "properties": {
        "url": {
          "type": "string", 
          "description": "URL of the shared link."
        }
      }
    }, 
    "GetMetadataError": {
      "type": "object", 
      "description": "path: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path"
          ], 
          "type": "string", 
          "title": "Choice of GetMetadataError"
        }
      }
    }, 
    "SharingPublicPolicyType": {
      "type": "object", 
      "description": "people_with_link_can_edit: Users who have a link to this doc can edit it.\npeople_with_link_can_view_and_comment: Users who have a link to this doc can view and comment on it.\ninvite_only: Users must be explicitly invited to this doc.\ndisabled: Value used to indicate that doc sharing is enabled only within team.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "people_with_link_can_edit", 
            "people_with_link_can_view_and_comment", 
            "invite_only", 
            "disabled"
          ], 
          "type": "string", 
          "title": "Choice of SharingPublicPolicyType"
        }
      }
    }, 
    "UpdateFileRequestDeadline": {
      "type": "object", 
      "description": "no_update: Do not change the file request's deadline.\nupdate: If :val:`null`, the file request's deadline is cleared.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "no_update", 
            "update", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UpdateFileRequestDeadline"
        }, 
        "update": {
          "$ref": "#/definitions/FileRequestDeadline"
        }
      }
    }, 
    "UpdatePropertiesError": {
      "type": "object", 
      "description": "template_not_found: Template does not exist for the given identifier.\nrestricted_content: You do not have permission to modify this template.\nother: None\npath: None\nunsupported_folder: This folder cannot be tagged. Tagging folders is not supported for team-owned templates.\nproperty_field_too_large: One or more of the supplied property field values is too large.\ndoes_not_fit_template: One or more of the supplied property fields does not conform to the template specifications.\nproperty_group_lookup: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "template_not_found", 
            "restricted_content", 
            "other", 
            "path", 
            "unsupported_folder", 
            "property_field_too_large", 
            "does_not_fit_template", 
            "property_group_lookup"
          ], 
          "type": "string", 
          "title": "Choice of UpdatePropertiesError"
        }, 
        "property_group_lookup": {
          "$ref": "#/definitions/LookUpPropertiesError"
        }, 
        "template_not_found": {
          "type": "string", 
          "description": "Template does not exist for the given identifier."
        }
      }
    }, 
    "RemovePropertiesArg": {
      "type": "object", 
      "description": "path: A unique identifier for the file or folder.\nproperty_template_ids: A list of identifiers for a template created by :route:`templates/add_for_user` or :route:`templates/add_for_team`.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "A unique identifier for the file or folder."
        }, 
        "property_template_ids": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "A list of identifiers for a template created by :route:`templates/add_for_user` or :route:`templates/add_for_team`."
        }
      }
    }, 
    "UpdateFolderMemberArg": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\nmember: The member of the shared folder to update.  Only the :field:`MemberSelector.dropbox_id` may be set at this time.\naccess_level: The new access level for :field:`member`. :field:`AccessLevel.owner` is disallowed.\n", 
      "properties": {
        "member": {
          "$ref": "#/definitions/MemberSelector"
        }, 
        "access_level": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }
      }
    }, 
    "CreateSharedLinkWithSettingsError": {
      "type": "object", 
      "description": "path: None\nemail_not_verified: User's email should be verified.\nshared_link_already_exists: The shared link already exists. You can call :route:`list_shared_links` to get the existing link.\nsettings_error: There is an error with the given settings.\naccess_denied: Access to the requested path is forbidden.\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "email_not_verified", 
            "shared_link_already_exists", 
            "settings_error", 
            "access_denied"
          ], 
          "type": "string", 
          "title": "Choice of CreateSharedLinkWithSettingsError"
        }, 
        "settings_error": {
          "$ref": "#/definitions/SharedLinkSettingsError"
        }
      }
    }, 
    "SearchMode": {
      "type": "object", 
      "description": "filename: Search file and folder names.\nfilename_and_content: Search file and folder names as well as file contents.\ndeleted_filename: Search for deleted file and folder names.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "filename", 
            "filename_and_content", 
            "deleted_filename"
          ], 
          "type": "string", 
          "title": "Choice of SearchMode"
        }
      }
    }, 
    "SharedFileMetadata": {
      "type": "object", 
      "description": "Properties of the shared file.\nid: The ID of the file.\nname: The name of this file.\npolicy: Policies governing this shared file.\npreview_url: URL for displaying a web preview of the shared file.\naccess_type: The current user's access level for this shared file.\nexpected_link_metadata: The expected metadata of the link associated for the file when it is first shared. Absent if the link already exists. This is for an unreleased feature so it may not be returned yet.\nlink_metadata: The metadata of the link associated for the file. This is for an unreleased feature so it may not be returned yet.\nowner_display_names: The display names of the users that own the file. If the file is part of a team folder, the display names of the team admins are also included. Absent if the owner display names cannot be fetched.\nowner_team: The team that owns the file. This field is not present if the file is not owned by a team.\nparent_shared_folder_id: The ID of the parent shared folder. This field is present only if the file is contained within a shared folder.\npath_display: The cased path to be used for display purposes only. In rare instances the casing will not correctly match the user's filesystem, but this behavior will match the path provided in the Core API v1. Absent for unmounted files.\npath_lower: The lower-case full path of this file. Absent for unmounted files.\npermissions: The sharing permissions that requesting user has on this file. This corresponds to the entries given in :field:`GetFileMetadataBatchArg.actions` or :field:`GetFileMetadataArg.actions`.\ntime_invited: Timestamp indicating when the current user was invited to this shared file. If the user was not invited to the shared file, the timestamp will indicate when the user was invited to the parent shared folder. This value may be absent.\n", 
      "properties": {
        "owner_team": {
          "$ref": "#/definitions/Team"
        }, 
        "parent_shared_folder_id": {
          "type": "string", 
          "description": "The ID of the parent shared folder. This field is present only if the file is contained within a shared folder."
        }, 
        "name": {
          "type": "string", 
          "description": "The name of this file."
        }, 
        "time_invited": {
          "type": "string", 
          "description": "Timestamp indicating when the current user was invited to this shared file. If the user was not invited to the shared file, the timestamp will indicate when the user was invited to the parent shared folder. This value may be absent."
        }, 
        "preview_url": {
          "type": "string", 
          "description": "URL for displaying a web preview of the shared file."
        }, 
        "access_type": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "owner_display_names": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "The display names of the users that own the file. If the file is part of a team folder, the display names of the team admins are also included. Absent if the owner display names cannot be fetched."
        }, 
        "path_display": {
          "type": "string", 
          "description": "The cased path to be used for display purposes only. In rare instances the casing will not correctly match the user's filesystem, but this behavior will match the path provided in the Core API v1. Absent for unmounted files."
        }, 
        "expected_link_metadata": {
          "$ref": "#/definitions/ExpectedSharedContentLinkMetadata"
        }, 
        "path_lower": {
          "type": "string", 
          "description": "The lower-case full path of this file. Absent for unmounted files."
        }, 
        "policy": {
          "$ref": "#/definitions/FolderPolicy"
        }, 
        "permissions": {
          "items": {
            "$ref": "#/definitions/FilePermission"
          }, 
          "type": "array", 
          "description": "The sharing permissions that requesting user has on this file. This corresponds to the entries given in :field:`GetFileMetadataBatchArg.actions` or :field:`GetFileMetadataArg.actions`."
        }, 
        "id": {
          "type": "string", 
          "description": "The ID of the file."
        }, 
        "link_metadata": {
          "$ref": "#/definitions/SharedContentLinkMetadata"
        }
      }
    }, 
    "ThumbnailMode": {
      "type": "object", 
      "description": "strict: Scale down the image to fit within the given size.\nbestfit: Scale down the image to fit within the given size or its transpose.\nfitone_bestfit: Scale down the image to completely cover the given size or its transpose.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "strict", 
            "bestfit", 
            "fitone_bestfit"
          ], 
          "type": "string", 
          "title": "Choice of ThumbnailMode"
        }
      }
    }, 
    "AddFileMemberArgs": {
      "type": "object", 
      "description": "Arguments for :route:`add_file_member`.\nfile: File to which to add members.\nmembers: Members to add. Note that even an email address is given, this may result in a user being directy added to the membership if that email is the user's main account email.\ncustom_message: Message to send to added members in their invitation.\nquiet: Whether added members should be notified via device notifications of their invitation.\naccess_level: AccessLevel union object, describing what access level we want to give new members.\nadd_message_as_comment: If the custom message should be added as a comment on the file.\n", 
      "properties": {
        "members": {
          "items": {
            "$ref": "#/definitions/MemberSelector"
          }, 
          "type": "array", 
          "description": "Members to add. Note that even an email address is given, this may result in a user being directy added to the membership if that email is the user's main account email."
        }, 
        "quiet": {
          "type": "boolean", 
          "description": "Whether added members should be notified via device notifications of their invitation."
        }, 
        "add_message_as_comment": {
          "type": "boolean", 
          "description": "If the custom message should be added as a comment on the file."
        }, 
        "access_level": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "file": {
          "type": "string", 
          "description": "File to which to add members."
        }, 
        "custom_message": {
          "type": "string", 
          "description": "Message to send to added members in their invitation."
        }
      }
    }, 
    "ShareFolderJobStatus": {
      "type": "object", 
      "description": "in_progress: The asynchronous job is still in progress.\ncomplete: The share job has finished. The value is the metadata for the folder.\nfailed: None\n", 
      "properties": {
        "failed": {
          "$ref": "#/definitions/ShareFolderError"
        }, 
        ".tag": {
          "enum": [
            "in_progress", 
            "complete", 
            "failed"
          ], 
          "type": "string", 
          "title": "Choice of ShareFolderJobStatus"
        }, 
        "complete": {
          "$ref": "#/definitions/SharedFolderMetadata"
        }
      }
    }, 
    "RelocationPath": {
      "type": "object", 
      "description": "from_path: Path in the user's Dropbox to be copied or moved.\nto_path: Path in the user's Dropbox that is the destination.\n", 
      "properties": {
        "from_path": {
          "type": "string", 
          "description": "Path in the user's Dropbox to be copied or moved."
        }, 
        "to_path": {
          "type": "string", 
          "description": "Path in the user's Dropbox that is the destination."
        }
      }
    }, 
    "SharedFolderJoinPolicy": {
      "type": "object", 
      "description": "Policy governing which shared folders a team member can join.\nfrom_team_only: Team members can only join folders shared by teammates.\nfrom_anyone: Team members can join any shared folder, including those shared by users outside the team.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "from_team_only", 
            "from_anyone", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharedFolderJoinPolicy"
        }
      }
    }, 
    "IndividualSpaceAllocation": {
      "type": "object", 
      "description": "allocated: The total space allocated to the user's account (bytes).\n", 
      "properties": {
        "allocated": {
          "type": "number", 
          "description": "The total space allocated to the user's account (bytes)."
        }
      }
    }, 
    "ListRevisionsArg": {
      "type": "object", 
      "description": "path: The path to the file you want to see the revisions of.\nmode: Determines the behavior of the API in listing the revisions for a given file path or id.\nlimit: The maximum number of revision entries returned.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path to the file you want to see the revisions of."
        }, 
        "limit": {
          "type": "number", 
          "description": "The maximum number of revision entries returned."
        }, 
        "mode": {
          "$ref": "#/definitions/ListRevisionsMode"
        }
      }
    }, 
    "CommitInfoWithProperties": {
      "type": "object", 
      "description": "path: Path in the user's Dropbox to save the file.\nmode: Selects what to do if the file already exists.\nautorename: If there's a conflict, as determined by :field:`mode`, have the Dropbox server try to autorename the file to avoid conflict.\nclient_modified: The value to store as the :field:`client_modified` timestamp. Dropbox automatically records the time at which the file was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or modified.\nmute: Normally, users are made aware of any file modifications in their Dropbox account via notifications in the client software. If :val:`true`, this tells the clients that this modification shouldn't result in a user notification.\nproperty_groups: List of custom properties to add to file.\n", 
      "properties": {
        "autorename": {
          "type": "boolean", 
          "description": "If there's a conflict, as determined by :field:`mode`, have the Dropbox server try to autorename the file to avoid conflict."
        }, 
        "mute": {
          "type": "boolean", 
          "description": "Normally, users are made aware of any file modifications in their Dropbox account via notifications in the client software. If :val:`true`, this tells the clients that this modification shouldn't result in a user notification."
        }, 
        "client_modified": {
          "type": "string", 
          "description": "The value to store as the :field:`client_modified` timestamp. Dropbox automatically records the time at which the file was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or modified."
        }, 
        "mode": {
          "$ref": "#/definitions/WriteMode"
        }, 
        "path": {
          "type": "string", 
          "description": "Path in the user's Dropbox to save the file."
        }, 
        "property_groups": {
          "items": {
            "$ref": "#/definitions/PropertyGroup"
          }, 
          "type": "array", 
          "description": "List of custom properties to add to file."
        }
      }
    }, 
    "ListUsersOnPaperDocArgs": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\nlimit: Size limit per batch. The maximum number of users that can be retrieved per batch is 1000. Higher value results in invalid arguments error.\nfilter_by: Specify this attribute if you want to obtain users that have already accessed the Paper doc.\n", 
      "properties": {
        "limit": {
          "type": "number", 
          "description": "Size limit per batch. The maximum number of users that can be retrieved per batch is 1000. Higher value results in invalid arguments error."
        }, 
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }, 
        "filter_by": {
          "$ref": "#/definitions/UserOnPaperDocFilter"
        }
      }
    }, 
    "ListFilesArg": {
      "type": "object", 
      "description": "Arguments for :route:`list_received_files`.\nlimit: Number of files to return max per query. Defaults to 100 if no limit is specified.\nactions: A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's :field:`SharedFileMetadata.permissions` field describing the actions the  authenticated user can perform on the file.\n", 
      "properties": {
        "limit": {
          "type": "number", 
          "description": "Number of files to return max per query. Defaults to 100 if no limit is specified."
        }, 
        "actions": {
          "items": {
            "$ref": "#/definitions/FileAction"
          }, 
          "type": "array", 
          "description": "A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's :field:`SharedFileMetadata.permissions` field describing the actions the  authenticated user can perform on the file."
        }
      }
    }, 
    "ListFoldersContinueArg": {
      "type": "object", 
      "description": "cursor: The cursor returned by the previous API call specified in the endpoint description.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "The cursor returned by the previous API call specified in the endpoint description."
        }
      }
    }, 
    "ListPaperDocsSortBy": {
      "type": "object", 
      "description": "accessed: Sorts the Paper docs by the time they were last accessed.\nmodified: Sorts the Paper docs by the time they were last modified.\ncreated: Sorts the Paper docs by the creation time.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "accessed", 
            "modified", 
            "created", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListPaperDocsSortBy"
        }
      }
    }, 
    "FolderPolicy": {
      "type": "object", 
      "description": "A set of policies governing membership and privileges for a shared folder.\nacl_update_policy: Who can add and remove members from this shared folder.\nshared_link_policy: Who links can be shared with.\nmember_policy: Who can be a member of this shared folder, as set on the folder itself. The effective policy may differ from this value if the team-wide policy is more restrictive. Present only if the folder is owned by a team.\nresolved_member_policy: Who can be a member of this shared folder, taking into account both the folder and the team-wide policy. This value may differ from that of member_policy if the team-wide policy is more restrictive than the folder policy. Present only if the folder is owned by a team.\nviewer_info_policy: Who can enable/disable viewer info for this shared folder.\n", 
      "properties": {
        "viewer_info_policy": {
          "$ref": "#/definitions/ViewerInfoPolicy"
        }, 
        "resolved_member_policy": {
          "$ref": "#/definitions/MemberPolicy"
        }, 
        "acl_update_policy": {
          "$ref": "#/definitions/AclUpdatePolicy"
        }, 
        "shared_link_policy": {
          "$ref": "#/definitions/SharedLinkPolicy"
        }, 
        "member_policy": {
          "$ref": "#/definitions/MemberPolicy"
        }
      }
    }, 
    "GetCopyReferenceArg": {
      "type": "object", 
      "description": "path: The path to the file or folder you want to get a copy reference to.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path to the file or folder you want to get a copy reference to."
        }
      }
    }, 
    "CreateFolderBatchArg": {
      "type": "object", 
      "description": "paths: List of paths to be created in the user's Dropbox. Duplicate path arguments in the batch are considered only once.\nautorename: If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict.\nforce_async: Whether to force the create to happen asynchronously.\n", 
      "properties": {
        "paths": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "List of paths to be created in the user's Dropbox. Duplicate path arguments in the batch are considered only once."
        }, 
        "force_async": {
          "type": "boolean", 
          "description": "Whether to force the create to happen asynchronously."
        }, 
        "autorename": {
          "type": "boolean", 
          "description": "If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict."
        }
      }
    }, 
    "SharedLinkSettingsError": {
      "type": "object", 
      "description": "invalid_settings: The given settings are invalid (for example, all attributes of the :type:`SharedLinkSettings` are empty, the requested visibility is :field:`RequestedVisibility.password` but the :field:`SharedLinkSettings.link_password` is missing, :field:`SharedLinkSettings.expires` is set to the past, etc.).\nnot_authorized: User is not allowed to modify the settings of this link. Note that basic users can only set :field:`RequestedVisibility.public` as the :field:`SharedLinkSettings.requested_visibility` and cannot set :field:`SharedLinkSettings.expires`.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "invalid_settings", 
            "not_authorized"
          ], 
          "type": "string", 
          "title": "Choice of SharedLinkSettingsError"
        }
      }
    }, 
    "TeamMemberInfo": {
      "type": "object", 
      "description": "Information about a team member.\nteam_info: Information about the member's team.\ndisplay_name: The display name of the user.\nmember_id: ID of user as a member of a team. This field will only be present if the member is in the same team as current user.\n", 
      "properties": {
        "member_id": {
          "type": "string", 
          "description": "ID of user as a member of a team. This field will only be present if the member is in the same team as current user."
        }, 
        "display_name": {
          "type": "string", 
          "description": "The display name of the user."
        }, 
        "team_info": {
          "$ref": "#/definitions/Team"
        }
      }
    }, 
    "SaveCopyReferenceError": {
      "type": "object", 
      "description": "path: None\ninvalid_copy_reference: The copy reference is invalid.\nno_permission: You don't have permission to save the given copy reference. Please make sure this app is same app which created the copy reference and the source user is still linked to the app.\nnot_found: The file referenced by the copy reference cannot be found.\ntoo_many_files: The operation would involve more than 10,000 files and folders.\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/WriteError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "invalid_copy_reference", 
            "no_permission", 
            "not_found", 
            "too_many_files", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SaveCopyReferenceError"
        }
      }
    }, 
    "ListFoldersArgs": {
      "type": "object", 
      "description": "limit: The maximum number of results to return per request.\nactions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's :field:`SharedFolderMetadata.permissions` field describing the actions the  authenticated user can perform on the folder.\n", 
      "properties": {
        "limit": {
          "type": "number", 
          "description": "The maximum number of results to return per request."
        }, 
        "actions": {
          "items": {
            "$ref": "#/definitions/FolderAction"
          }, 
          "type": "array", 
          "description": "A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's :field:`SharedFolderMetadata.permissions` field describing the actions the  authenticated user can perform on the folder."
        }
      }
    }, 
    "FileMemberRemoveActionResult": {
      "type": "object", 
      "description": "success: Member was successfully removed from this file.\nmember_error: User was not able to remove this member.\nother: None\n", 
      "properties": {
        "member_error": {
          "$ref": "#/definitions/FileMemberActionError"
        }, 
        ".tag": {
          "enum": [
            "success", 
            "member_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of FileMemberRemoveActionResult"
        }, 
        "success": {
          "$ref": "#/definitions/MemberAccessLevelResult"
        }
      }
    }, 
    "SharedLinkPolicy": {
      "type": "object", 
      "description": "Who can view shared links in this folder.\nanyone: Links can be shared with anyone.\nteam: Links can be shared with anyone on the same team as the owner.\nmembers: Links can only be shared among members of the shared folder.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "anyone", 
            "team", 
            "members", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharedLinkPolicy"
        }
      }
    }, 
    "ListFileMembersBatchResult": {
      "type": "object", 
      "description": "Per-file result for :route:`list_file_members/batch`.\nfile: This is the input file identifier, whether an ID or a path.\nresult: The result for this particular file.\n", 
      "properties": {
        "result": {
          "$ref": "#/definitions/ListFileMembersIndividualResult"
        }, 
        "file": {
          "type": "string", 
          "description": "This is the input file identifier, whether an ID or a path."
        }
      }
    }, 
    "AudienceExceptionContentInfo": {
      "type": "object", 
      "description": "Information about the content that has a link audience different than that of this folder.\nname: The name of the content, which is either a file or a folder.\n", 
      "properties": {
        "name": {
          "type": "string", 
          "description": "The name of the content, which is either a file or a folder."
        }
      }
    }, 
    "ListUsersOnFolderResponse": {
      "type": "object", 
      "description": "invitees: List of email addresses that are invited on the Paper folder.\nusers: List of users that are invited on the Paper folder.\ncursor: Pass the cursor into :route:`docs/folder_users/list/continue` to paginate through all users. The cursor preserves all properties as specified in the original call to :route:`docs/folder_users/list`.\nhas_more: Will be set to True if a subsequent call with the provided cursor to :route:`docs/folder_users/list/continue` returns immediately with some results. If set to False please allow some delay before making another call to :route:`docs/folder_users/list/continue`.\n", 
      "properties": {
        "cursor": {
          "$ref": "#/definitions/Cursor"
        }, 
        "has_more": {
          "type": "boolean", 
          "description": "Will be set to True if a subsequent call with the provided cursor to :route:`docs/folder_users/list/continue` returns immediately with some results. If set to False please allow some delay before making another call to :route:`docs/folder_users/list/continue`."
        }, 
        "users": {
          "items": {
            "$ref": "#/definitions/UserInfo"
          }, 
          "type": "array", 
          "description": "List of users that are invited on the Paper folder."
        }, 
        "invitees": {
          "items": {
            "$ref": "#/definitions/InviteeInfo"
          }, 
          "type": "array", 
          "description": "List of email addresses that are invited on the Paper folder."
        }
      }
    }, 
    "MountFolderError": {
      "type": "object", 
      "description": "access_error: None\ninside_shared_folder: Mounting would cause a shared folder to be inside another, which is disallowed.\ninsufficient_quota: The current user does not have enough space to mount the shared folder.\nalready_mounted: The shared folder is already mounted.\nno_permission: The current user does not have permission to perform this action.\nnot_mountable: The shared folder is not mountable. One example where this can occur is when the shared folder belongs within a team folder in the user's Dropbox.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        "insufficient_quota": {
          "$ref": "#/definitions/InsufficientQuotaAmounts"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "inside_shared_folder", 
            "insufficient_quota", 
            "already_mounted", 
            "no_permission", 
            "not_mountable", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of MountFolderError"
        }
      }
    }, 
    "GetSharedLinkFileError": {
      "type": "object", 
      "description": "shared_link_not_found: The shared link wasn't found.\nshared_link_access_denied: The caller is not allowed to access this shared link.\nunsupported_link_type: This type of link is not supported.\nother: None\nshared_link_is_directory: Directories cannot be retrieved by this endpoint.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "shared_link_not_found", 
            "shared_link_access_denied", 
            "unsupported_link_type", 
            "other", 
            "shared_link_is_directory"
          ], 
          "type": "string", 
          "title": "Choice of GetSharedLinkFileError"
        }
      }
    }, 
    "DownloadError": {
      "type": "object", 
      "description": "path: None\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of DownloadError"
        }
      }
    }, 
    "RefPaperDoc": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\n", 
      "properties": {
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }
      }
    }, 
    "CommitInfo": {
      "type": "object", 
      "description": "path: Path in the user's Dropbox to save the file.\nmode: Selects what to do if the file already exists.\nautorename: If there's a conflict, as determined by :field:`mode`, have the Dropbox server try to autorename the file to avoid conflict.\nclient_modified: The value to store as the :field:`client_modified` timestamp. Dropbox automatically records the time at which the file was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or modified.\nmute: Normally, users are made aware of any file modifications in their Dropbox account via notifications in the client software. If :val:`true`, this tells the clients that this modification shouldn't result in a user notification.\nproperty_groups: List of custom properties to add to file.\n", 
      "properties": {
        "autorename": {
          "type": "boolean", 
          "description": "If there's a conflict, as determined by :field:`mode`, have the Dropbox server try to autorename the file to avoid conflict."
        }, 
        "mute": {
          "type": "boolean", 
          "description": "Normally, users are made aware of any file modifications in their Dropbox account via notifications in the client software. If :val:`true`, this tells the clients that this modification shouldn't result in a user notification."
        }, 
        "client_modified": {
          "type": "string", 
          "description": "The value to store as the :field:`client_modified` timestamp. Dropbox automatically records the time at which the file was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of when the file was actually created or modified."
        }, 
        "mode": {
          "$ref": "#/definitions/WriteMode"
        }, 
        "path": {
          "type": "string", 
          "description": "Path in the user's Dropbox to save the file."
        }, 
        "property_groups": {
          "items": {
            "$ref": "#/definitions/PropertyGroup"
          }, 
          "type": "array", 
          "description": "List of custom properties to add to file."
        }
      }
    }, 
    "UserMembershipInfo": {
      "type": "object", 
      "description": "The information about a user member of the shared content.\naccess_type: The access type for this member.\nuser: The account information for the membership user.\npermissions: The permissions that requesting user has on this member. The set of permissions corresponds to the MemberActions in the request.\ninitials: Never set.\nis_inherited: True if the member has access from a parent folder.\n", 
      "properties": {
        "initials": {
          "type": "string", 
          "description": "Never set."
        }, 
        "permissions": {
          "items": {
            "$ref": "#/definitions/MemberPermission"
          }, 
          "type": "array", 
          "description": "The permissions that requesting user has on this member. The set of permissions corresponds to the MemberActions in the request."
        }, 
        "user": {
          "$ref": "#/definitions/UserInfo"
        }, 
        "access_type": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "is_inherited": {
          "type": "boolean", 
          "description": "True if the member has access from a parent folder."
        }
      }
    }, 
    "SpaceAllocation": {
      "type": "object", 
      "description": "Space is allocated differently based on the type of account.\nindividual: The user's space allocation applies only to their individual account.\nteam: The user shares space with other members of their team.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "individual", 
            "team", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SpaceAllocation"
        }, 
        "individual": {
          "$ref": "#/definitions/IndividualSpaceAllocation"
        }, 
        "team": {
          "$ref": "#/definitions/TeamSpaceAllocation"
        }
      }
    }, 
    "PaperDocSharingPolicy": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\nsharing_policy: The default sharing policy to be set for the Paper doc.\n", 
      "properties": {
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }, 
        "sharing_policy": {
          "$ref": "#/definitions/SharingPolicy"
        }
      }
    }, 
    "InsufficientQuotaAmounts": {
      "type": "object", 
      "description": "space_needed: The amount of space needed to add the item (the size of the item).\nspace_shortage: The amount of extra space needed to add the item.\nspace_left: The amount of space left in the user's Dropbox, less than space_needed.\n", 
      "properties": {
        "space_shortage": {
          "type": "number", 
          "description": "The amount of extra space needed to add the item."
        }, 
        "space_left": {
          "type": "number", 
          "description": "The amount of space left in the user's Dropbox, less than space_needed."
        }, 
        "space_needed": {
          "type": "number", 
          "description": "The amount of space needed to add the item (the size of the item)."
        }
      }
    }, 
    "AccountType": {
      "type": "object", 
      "description": "What type of account this user has.\nbasic: The basic account type.\npro: The Dropbox Pro account type.\nbusiness: The Dropbox Business account type.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "basic", 
            "pro", 
            "business"
          ], 
          "type": "string", 
          "title": "Choice of AccountType"
        }
      }
    }, 
    "GpsCoordinates": {
      "type": "object", 
      "description": "GPS coordinates for a photo or video.\nlatitude: Latitude of the GPS coordinates.\nlongitude: Longitude of the GPS coordinates.\n", 
      "properties": {
        "latitude": {
          "type": "number", 
          "description": "Latitude of the GPS coordinates."
        }, 
        "longitude": {
          "type": "number", 
          "description": "Longitude of the GPS coordinates."
        }
      }
    }, 
    "FullTeam": {
      "type": "object", 
      "description": "Detailed information about a team.\nid: The team's unique ID.\nname: The name of the team.\nsharing_policies: Team policies governing sharing.\noffice_addin_policy: Team policy governing the use of the Office Add-In.\n", 
      "properties": {
        "sharing_policies": {
          "$ref": "#/definitions/TeamSharingPolicies"
        }, 
        "office_addin_policy": {
          "$ref": "#/definitions/OfficeAddInPolicy"
        }, 
        "id": {
          "type": "string", 
          "description": "The team's unique ID."
        }, 
        "name": {
          "type": "string", 
          "description": "The name of the team."
        }
      }
    }, 
    "ListFolderMembersContinueArg": {
      "type": "object", 
      "description": "cursor: The cursor returned by your last call to :route:`list_folder_members` or :route:`list_folder_members/continue`.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "The cursor returned by your last call to :route:`list_folder_members` or :route:`list_folder_members/continue`."
        }
      }
    }, 
    "ListUsersOnPaperDocContinueArgs": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\ncursor: The cursor obtained from :route:`docs/users/list` or :route:`docs/users/list/continue`. Allows for pagination.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "The cursor obtained from :route:`docs/users/list` or :route:`docs/users/list/continue`. Allows for pagination."
        }, 
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }
      }
    }, 
    "ListFilesContinueError": {
      "type": "object", 
      "description": "Error results for :route:`list_received_files/continue`.\nuser_error: User account had a problem.\ninvalid_cursor: :field:`ListFilesContinueArg.cursor` is invalid.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "user_error", 
            "invalid_cursor", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFilesContinueError"
        }, 
        "user_error": {
          "$ref": "#/definitions/SharingUserError"
        }
      }
    }, 
    "ListFolderContinueArg": {
      "type": "object", 
      "description": "cursor: The cursor returned by your last call to :route:`list_folder` or :route:`list_folder/continue`.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "The cursor returned by your last call to :route:`list_folder` or :route:`list_folder/continue`."
        }
      }
    }, 
    "InviteeInfo": {
      "type": "object", 
      "description": "Information about the recipient of a shared content invitation.\nemail: E-mail address of invited user.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "email", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of InviteeInfo"
        }, 
        "email": {
          "type": "string", 
          "description": "E-mail address of invited user."
        }
      }
    }, 
    "RemoveMemberJobStatus": {
      "type": "object", 
      "description": "in_progress: The asynchronous job is still in progress.\ncomplete: Removing the folder member has finished. The value is information about whether the member has another form of access.\nfailed: None\n", 
      "properties": {
        "failed": {
          "$ref": "#/definitions/RemoveFolderMemberError"
        }, 
        ".tag": {
          "enum": [
            "in_progress", 
            "complete", 
            "failed"
          ], 
          "type": "string", 
          "title": "Choice of RemoveMemberJobStatus"
        }, 
        "complete": {
          "$ref": "#/definitions/MemberAccessLevelResult"
        }
      }
    }, 
    "TeamSpaceAllocation": {
      "type": "object", 
      "description": "used: The total space currently used by the user's team (bytes).\nallocated: The total space allocated to the user's team (bytes).\nuser_within_team_space_allocated: The total space allocated to the user within its team allocated space (0 means that no restriction is imposed on the user's quota within its team).\nuser_within_team_space_limit_type: The type of the space limit imposed on the team member (off, alert_only, stop_sync).\n", 
      "properties": {
        "allocated": {
          "type": "number", 
          "description": "The total space allocated to the user's team (bytes)."
        }, 
        "used": {
          "type": "number", 
          "description": "The total space currently used by the user's team (bytes)."
        }, 
        "user_within_team_space_limit_type": {
          "$ref": "#/definitions/MemberSpaceLimitType"
        }, 
        "user_within_team_space_allocated": {
          "type": "number", 
          "description": "The total space allocated to the user within its team allocated space (0 means that no restriction is imposed on the user's quota within its team)."
        }
      }
    }, 
    "FolderSharingInfo": {
      "type": "object", 
      "description": "Sharing info for a folder which is contained in a shared folder or is a shared folder mount point.\nread_only: True if the file or folder is inside a read-only shared folder.\nparent_shared_folder_id: Set if the folder is contained by a shared folder.\nshared_folder_id: If this folder is a shared folder mount point, the ID of the shared folder mounted at this location.\ntraverse_only: Specifies that the folder can only be traversed and the user can only see a limited subset of the contents of this folder because they don't have read access to this folder. They do, however, have access to some sub folder.\nno_access: Specifies that the folder cannot be accessed by the user.\n", 
      "properties": {
        "read_only": {
          "type": "boolean", 
          "description": "True if the file or folder is inside a read-only shared folder."
        }, 
        "parent_shared_folder_id": {
          "type": "string", 
          "description": "Set if the folder is contained by a shared folder."
        }, 
        "traverse_only": {
          "type": "boolean", 
          "description": "Specifies that the folder can only be traversed and the user can only see a limited subset of the contents of this folder because they don't have read access to this folder. They do, however, have access to some sub folder."
        }, 
        "shared_folder_id": {
          "type": "string", 
          "description": "If this folder is a shared folder mount point, the ID of the shared folder mounted at this location."
        }, 
        "no_access": {
          "type": "boolean", 
          "description": "Specifies that the folder cannot be accessed by the user."
        }
      }
    }, 
    "ListFileMembersArg": {
      "type": "object", 
      "description": "Arguments for :route:`list_file_members`.\nfile: The file for which you want to see members.\nactions: The actions for which to return permissions on a member.\ninclude_inherited: Whether to include members who only have access from a parent shared folder.\nlimit: Number of members to return max per query. Defaults to 100 if no limit is specified.\n", 
      "properties": {
        "include_inherited": {
          "type": "boolean", 
          "description": "Whether to include members who only have access from a parent shared folder."
        }, 
        "limit": {
          "type": "number", 
          "description": "Number of members to return max per query. Defaults to 100 if no limit is specified."
        }, 
        "actions": {
          "items": {
            "$ref": "#/definitions/MemberAction"
          }, 
          "type": "array", 
          "description": "The actions for which to return permissions on a member."
        }, 
        "file": {
          "type": "string", 
          "description": "The file for which you want to see members."
        }
      }
    }, 
    "RemovePropertiesError": {
      "type": "object", 
      "description": "template_not_found: Template does not exist for the given identifier.\nrestricted_content: You do not have permission to modify this template.\nother: None\npath: None\nunsupported_folder: This folder cannot be tagged. Tagging folders is not supported for team-owned templates.\nproperty_group_lookup: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "template_not_found", 
            "restricted_content", 
            "other", 
            "path", 
            "unsupported_folder", 
            "property_group_lookup"
          ], 
          "type": "string", 
          "title": "Choice of RemovePropertiesError"
        }, 
        "property_group_lookup": {
          "$ref": "#/definitions/LookUpPropertiesError"
        }, 
        "template_not_found": {
          "type": "string", 
          "description": "Template does not exist for the given identifier."
        }
      }
    }, 
    "LinkSettings": {
      "type": "object", 
      "description": "Settings that apply to a link.\naccess_level: The access level on the link for this file. Currently, it only accepts 'viewer' and 'viewer_no_comment'.\naudience: The type of audience on the link for this file.\nexpiry: An expiry timestamp to set on a link.\npassword: The password for the link.\n", 
      "properties": {
        "access_level": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "audience": {
          "$ref": "#/definitions/LinkAudience"
        }, 
        "password": {
          "$ref": "#/definitions/LinkPassword"
        }, 
        "expiry": {
          "$ref": "#/definitions/LinkExpiry"
        }
      }
    }, 
    "GetTemporaryLinkResult": {
      "type": "object", 
      "description": "metadata: Metadata of the file.\nlink: The temporary link which can be used to stream content the file.\n", 
      "properties": {
        "link": {
          "type": "string", 
          "description": "The temporary link which can be used to stream content the file."
        }, 
        "metadata": {
          "$ref": "#/definitions/FileMetadata"
        }
      }
    }, 
    "ListPaperDocsContinueArgs": {
      "type": "object", 
      "description": "cursor: The cursor obtained from :route:`docs/list` or :route:`docs/list/continue`. Allows for pagination.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "The cursor obtained from :route:`docs/list` or :route:`docs/list/continue`. Allows for pagination."
        }
      }
    }, 
    "TeamSharingPolicies": {
      "type": "object", 
      "description": "Policies governing sharing within and outside of the team.\nshared_folder_member_policy: Who can join folders shared by team members.\nshared_folder_join_policy: Which shared folders team members can join.\nshared_link_create_policy: Who can view shared links owned by team members.\n", 
      "properties": {
        "shared_folder_join_policy": {
          "$ref": "#/definitions/SharedFolderJoinPolicy"
        }, 
        "shared_folder_member_policy": {
          "$ref": "#/definitions/SharedFolderMemberPolicy"
        }, 
        "shared_link_create_policy": {
          "$ref": "#/definitions/SharedLinkCreatePolicy"
        }
      }
    }, 
    "FolderAction": {
      "type": "object", 
      "description": "Actions that may be taken on shared folders.\nchange_options: Change folder options, such as who can be invited to join the folder.\ndisable_viewer_info: Disable viewer information for this folder.\nedit_contents: Change or edit contents of the folder.\nenable_viewer_info: Enable viewer information on the folder.\ninvite_editor: Invite a user or group to join the folder with read and write permission.\ninvite_viewer: Invite a user or group to join the folder with read permission.\ninvite_viewer_no_comment: Invite a user or group to join the folder with read permission but no comment permissions.\nrelinquish_membership: Relinquish one's own membership in the folder.\nunmount: Unmount the folder.\nunshare: Stop sharing this folder.\nleave_a_copy: Keep a copy of the contents upon leaving or being kicked from the folder.\nshare_link: Use create_link instead.\ncreate_link: Create a shared link for folder.\nset_access_inheritance: Set whether the folder inherits permissions from its parent.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "change_options", 
            "disable_viewer_info", 
            "edit_contents", 
            "enable_viewer_info", 
            "invite_editor", 
            "invite_viewer", 
            "invite_viewer_no_comment", 
            "relinquish_membership", 
            "unmount", 
            "unshare", 
            "leave_a_copy", 
            "share_link", 
            "create_link", 
            "set_access_inheritance", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of FolderAction"
        }
      }
    }, 
    "RequestedVisibility": {
      "type": "object", 
      "description": "The access permission that can be requested by the caller for the shared link. Note that the final resolved visibility of the shared link takes into account other aspects, such as team and shared folder settings. Check the :type:`ResolvedVisibility` for more info on the possible resolved visibility values of shared links.\npublic: Anyone who has received the link can access it. No login required.\nteam_only: Only members of the same team can access the link. Login is required.\npassword: A link-specific password is required to access the link. Login is not required.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "public", 
            "team_only", 
            "password"
          ], 
          "type": "string", 
          "title": "Choice of RequestedVisibility"
        }
      }
    }, 
    "RelocationResult": {
      "type": "object", 
      "description": "metadata: Metadata of the relocated object.\n", 
      "properties": {
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      }
    }, 
    "ViewerInfoPolicy": {
      "type": "object", 
      "description": "enabled: Viewer information is available on this file.\ndisabled: Viewer information is disabled on this file.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "enabled", 
            "disabled", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ViewerInfoPolicy"
        }
      }
    }, 
    "PaperDocExport": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\nexport_format: None\n", 
      "properties": {
        "export_format": {
          "$ref": "#/definitions/ExportFormat"
        }, 
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }
      }
    }, 
    "ShareFolderLaunch": {
      "type": "object", 
      "description": "async_job_id: This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job.\ncomplete: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "async_job_id", 
            "complete"
          ], 
          "type": "string", 
          "title": "Choice of ShareFolderLaunch"
        }, 
        "async_job_id": {
          "type": "string", 
          "description": "This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job."
        }, 
        "complete": {
          "$ref": "#/definitions/SharedFolderMetadata"
        }
      }
    }, 
    "ListPaperDocsArgs": {
      "type": "object", 
      "description": "filter_by: Allows user to specify how the Paper docs should be filtered.\nsort_by: Allows user to specify how the Paper docs should be sorted.\nsort_order: Allows user to specify the sort order of the result.\nlimit: Size limit per batch. The maximum number of docs that can be retrieved per batch is 1000. Higher value results in invalid arguments error.\n", 
      "properties": {
        "sort_by": {
          "$ref": "#/definitions/ListPaperDocsSortBy"
        }, 
        "sort_order": {
          "$ref": "#/definitions/ListPaperDocsSortOrder"
        }, 
        "limit": {
          "type": "number", 
          "description": "Size limit per batch. The maximum number of docs that can be retrieved per batch is 1000. Higher value results in invalid arguments error."
        }, 
        "filter_by": {
          "$ref": "#/definitions/ListPaperDocsFilterBy"
        }
      }
    }, 
    "GetThumbnailBatchResultEntry": {
      "type": "object", 
      "description": "success: None\nfailure: The result for this file if it was an error.\nother: None\n", 
      "properties": {
        "failure": {
          "$ref": "#/definitions/ThumbnailError"
        }, 
        ".tag": {
          "enum": [
            "success", 
            "failure", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GetThumbnailBatchResultEntry"
        }, 
        "success": {
          "$ref": "#/definitions/GetThumbnailBatchResultData"
        }
      }
    }, 
    "UploadSessionLookupError": {
      "type": "object", 
      "description": "not_found: The upload session ID was not found or has expired. Upload sessions are valid for 48 hours.\nincorrect_offset: The specified offset was incorrect. See the value for the correct offset. This error may occur when a previous request was received and processed successfully but the client did not receive the response, e.g. due to a network error.\nclosed: You are attempting to append data to an upload session that has alread been closed (i.e. committed).\nnot_closed: The session must be closed before calling upload_session/finish_batch.\ntoo_large: You can not append to the upload session because the size of a file should not reach the max file size limit (i.e. 350GB).\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "not_found", 
            "incorrect_offset", 
            "closed", 
            "not_closed", 
            "too_large", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UploadSessionLookupError"
        }, 
        "incorrect_offset": {
          "$ref": "#/definitions/UploadSessionOffsetError"
        }
      }
    }, 
    "ListPaperDocsSortOrder": {
      "type": "object", 
      "description": "ascending: Sorts the search result in ascending order.\ndescending: Sorts the search result in descending order.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "ascending", 
            "descending", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListPaperDocsSortOrder"
        }
      }
    }, 
    "SaveUrlArg": {
      "type": "object", 
      "description": "path: The path in Dropbox where the URL will be saved to.\nurl: The URL to be saved.\n", 
      "properties": {
        "url": {
          "type": "string", 
          "description": "The URL to be saved."
        }, 
        "path": {
          "type": "string", 
          "description": "The path in Dropbox where the URL will be saved to."
        }
      }
    }, 
    "SearchResult": {
      "type": "object", 
      "description": "matches: A list (possibly empty) of matches for the query.\nmore: Used for paging. If true, indicates there is another page of results available that can be fetched by calling :route:`search` again.\nstart: Used for paging. Value to set the start argument to when calling :route:`search` to fetch the next page of results.\n", 
      "properties": {
        "matches": {
          "items": {
            "$ref": "#/definitions/SearchMatch"
          }, 
          "type": "array", 
          "description": "A list (possibly empty) of matches for the query."
        }, 
        "start": {
          "type": "number", 
          "description": "Used for paging. Value to set the start argument to when calling :route:`search` to fetch the next page of results."
        }, 
        "more": {
          "type": "boolean", 
          "description": "Used for paging. If true, indicates there is another page of results available that can be fetched by calling :route:`search` again."
        }
      }
    }, 
    "AddPaperDocUserResult": {
      "type": "object", 
      "description": "success: User was successfully added to the Paper doc.\nunknown_error: Something unexpected happened when trying to add the user to the Paper doc.\nsharing_outside_team_disabled: The Paper doc can be shared only with team members.\ndaily_limit_reached: The daily limit of how many users can be added to the Paper doc was reached.\nuser_is_owner: Owner's permissions cannot be changed.\nfailed_user_data_retrieval: User data could not be retrieved. Clients should retry.\npermission_already_granted: This user already has the correct permission to the Paper doc.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "success", 
            "unknown_error", 
            "sharing_outside_team_disabled", 
            "daily_limit_reached", 
            "user_is_owner", 
            "failed_user_data_retrieval", 
            "permission_already_granted", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of AddPaperDocUserResult"
        }
      }
    }, 
    "DownloadZipResult": {
      "type": "object", 
      "description": "metadata: None\n", 
      "properties": {
        "metadata": {
          "$ref": "#/definitions/FolderMetadata"
        }
      }
    }, 
    "ListFolderResult": {
      "type": "object", 
      "description": "entries: The files and (direct) subfolders in the folder.\ncursor: Pass the cursor into :route:`list_folder/continue` to see what's changed in the folder since your previous query.\nhas_more: If true, then there are more entries available. Pass the cursor to :route:`list_folder/continue` to retrieve the rest.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "Pass the cursor into :route:`list_folder/continue` to see what's changed in the folder since your previous query."
        }, 
        "has_more": {
          "type": "boolean", 
          "description": "If true, then there are more entries available. Pass the cursor to :route:`list_folder/continue` to retrieve the rest."
        }, 
        "entries": {
          "items": {
            "$ref": "#/definitions/Metadata"
          }, 
          "type": "array", 
          "description": "The files and (direct) subfolders in the folder."
        }
      }
    }, 
    "SharedFolderMemberError": {
      "type": "object", 
      "description": "invalid_dropbox_id: The target dropbox_id is invalid.\nnot_a_member: The target dropbox_id is not a member of the shared folder.\nno_explicit_access: The target member only has inherited access to the shared folder.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "invalid_dropbox_id", 
            "not_a_member", 
            "no_explicit_access", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharedFolderMemberError"
        }, 
        "no_explicit_access": {
          "$ref": "#/definitions/MemberAccessLevelResult"
        }
      }
    }, 
    "RevokeSharedLinkError": {
      "type": "object", 
      "description": "shared_link_not_found: The shared link wasn't found.\nshared_link_access_denied: The caller is not allowed to access this shared link.\nunsupported_link_type: This type of link is not supported.\nother: None\nshared_link_malformed: Shared link is malformed.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "shared_link_not_found", 
            "shared_link_access_denied", 
            "unsupported_link_type", 
            "other", 
            "shared_link_malformed"
          ], 
          "type": "string", 
          "title": "Choice of RevokeSharedLinkError"
        }
      }
    }, 
    "WriteMode": {
      "type": "object", 
      "description": "Your intent when writing a file to some path. This is used to determine what constitutes a conflict and what the autorename strategy is.\nIn some situations, the conflict behavior is identical: (a) If the target path doesn't refer to anything, the file is always written; no conflict. (b) If the target path refers to a folder, it's always a conflict. (c) If the target path refers to a file with identical contents, nothing gets written; no conflict.\nThe conflict checking differs in the case where there's a file at the target path with contents different from the contents you're trying to write.\nadd: Do not overwrite an existing file if there is a conflict. The autorename strategy is to append a number to the file name. For example, \"document.txt\" might become \"document (2).txt\".\noverwrite: Always overwrite the existing file. The autorename strategy is the same as it is for :field:`add`.\nupdate: Overwrite if the given \"rev\" matches the existing file's \"rev\". The autorename strategy is to append the string \"conflicted copy\" to the file name. For example, \"document.txt\" might become \"document (conflicted copy).txt\" or \"document (Panda's conflicted copy).txt\".\n", 
      "properties": {
        ".tag": {
          "enum": [
            "add", 
            "overwrite", 
            "update"
          ], 
          "type": "string", 
          "title": "Choice of WriteMode"
        }, 
        "update": {
          "type": "string", 
          "description": "Overwrite if the given \"rev\" matches the existing file's \"rev\". The autorename strategy is to append the string \"conflicted copy\" to the file name. For example, \"document.txt\" might become \"document (conflicted copy).txt\" or \"document (Panda's conflicted copy).txt\"."
        }
      }
    }, 
    "GroupInfo": {
      "type": "object", 
      "description": "The information about a group. Groups is a way to manage a list of users  who need same access permission to the shared folder.\ngroup_name: None\ngroup_id: None\ngroup_management_type: Who is allowed to manage the group.\ngroup_type: The type of group.\nis_member: If the current user is a member of the group.\nis_owner: If the current user is an owner of the group.\nsame_team: If the group is owned by the current user's team.\ngroup_external_id: External ID of group. This is an arbitrary ID that an admin can attach to a group.\nmember_count: The number of members in the group.\n", 
      "properties": {
        "group_external_id": {
          "type": "string", 
          "description": "External ID of group. This is an arbitrary ID that an admin can attach to a group."
        }, 
        "is_owner": {
          "type": "boolean", 
          "description": "If the current user is an owner of the group."
        }, 
        "member_count": {
          "type": "number", 
          "description": "The number of members in the group."
        }, 
        "same_team": {
          "type": "boolean", 
          "description": "If the group is owned by the current user's team."
        }, 
        "is_member": {
          "type": "boolean", 
          "description": "If the current user is a member of the group."
        }, 
        "group_management_type": {
          "$ref": "#/definitions/GroupManagementType"
        }, 
        "group_name": {
          "type": "string"
        }, 
        "group_id": {
          "type": "string"
        }, 
        "group_type": {
          "$ref": "#/definitions/GroupType"
        }
      }
    }, 
    "ListSharedLinksError": {
      "type": "object", 
      "description": "path: None\nreset: Indicates that the cursor has been invalidated. Call :route:`list_shared_links` to obtain a new cursor.\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "reset", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListSharedLinksError"
        }
      }
    }, 
    "AddTemplateArg": {
      "type": "object", 
      "description": "name: Display name for the template. Template names can be up to 256 bytes.\ndescription: Description for the template. Template descriptions can be up to 1024 bytes.\nfields: Definitions of the property fields associated with this template. There can be up to 32 properties in a single template.\n", 
      "properties": {
        "fields": {
          "items": {
            "$ref": "#/definitions/PropertyFieldTemplate"
          }, 
          "type": "array", 
          "description": "Definitions of the property fields associated with this template. There can be up to 32 properties in a single template."
        }, 
        "name": {
          "type": "string", 
          "description": "Display name for the template. Template names can be up to 256 bytes."
        }, 
        "description": {
          "type": "string", 
          "description": "Description for the template. Template descriptions can be up to 1024 bytes."
        }
      }
    }, 
    "Cursor": {
      "type": "object", 
      "description": "value: The actual cursor value.\nexpiration: Expiration time of :field:`value`.\nSome cursors might have expiration time assigned. This is a UTC value after which the cursor is no longer valid and the API starts returning an error. If cursor expires a new one needs to be obtained and pagination needs to be restarted. Some cursors might be short-lived some cursors might be long-lived.\nThis really depends on the sorting type and order, e.g.:\n1. on one hand, listing docs created by the user, sorted by the created time ascending will have undefinite expiration because the results cannot change while the iteration is happening. This cursor would be suitable for long term polling.\n2. on the other hand, listing docs sorted by the last modified time will have a very short expiration as docs do get modified very often and the modified time can be changed while the iteration is happening thus altering the results.\n", 
      "properties": {
        "expiration": {
          "type": "string", 
          "description": "Expiration time of :field:`value`.\nSome cursors might have expiration time assigned. This is a UTC value after which the cursor is no longer valid and the API starts returning an error. If cursor expires a new one needs to be obtained and pagination needs to be restarted. Some cursors might be short-lived some cursors might be long-lived.\nThis really depends on the sorting type and order, e.g.:\n1. on one hand, listing docs created by the user, sorted by the created time ascending will have undefinite expiration because the results cannot change while the iteration is happening. This cursor would be suitable for long term polling.\n2. on the other hand, listing docs sorted by the last modified time will have a very short expiration as docs do get modified very often and the modified time can be changed while the iteration is happening thus altering the results."
        }, 
        "value": {
          "type": "string", 
          "description": "The actual cursor value."
        }
      }
    }, 
    "AddTemplateResult": {
      "type": "object", 
      "description": "template_id: An identifier for template added by  See :route:`templates/add_for_user` or :route:`templates/add_for_team`.\n", 
      "properties": {
        "template_id": {
          "type": "string", 
          "description": "An identifier for template added by  See :route:`templates/add_for_user` or :route:`templates/add_for_team`."
        }
      }
    }, 
    "UnshareFolderError": {
      "type": "object", 
      "description": "access_error: None\nteam_folder: This action cannot be performed on a team shared folder.\nno_permission: The current user does not have permission to perform this action.\ntoo_many_files: This shared folder has too many files to be unshared.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "team_folder", 
            "no_permission", 
            "too_many_files", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UnshareFolderError"
        }
      }
    }, 
    "MemberPermission": {
      "type": "object", 
      "description": "Whether the user is allowed to take the action on the associated member.\naction: The action that the user may wish to take on the member.\nallow: True if the user is allowed to take the action.\nreason: The reason why the user is denied the permission. Not present if the action is allowed.\n", 
      "properties": {
        "action": {
          "$ref": "#/definitions/MemberAction"
        }, 
        "reason": {
          "$ref": "#/definitions/PermissionDeniedReason"
        }, 
        "allow": {
          "type": "boolean", 
          "description": "True if the user is allowed to take the action."
        }
      }
    }, 
    "SharingFileAccessError": {
      "type": "object", 
      "description": "User could not access this file.\nno_permission: Current user does not have sufficient privileges to perform the desired action.\ninvalid_file: File specified was not found.\nis_folder: A folder can't be shared this way. Use folder sharing or a shared link instead.\ninside_public_folder: A file inside a public folder can't be shared this way. Use a public link instead.\ninside_osx_package: A Mac OS X package can't be shared this way. Use a shared link instead.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "no_permission", 
            "invalid_file", 
            "is_folder", 
            "inside_public_folder", 
            "inside_osx_package", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharingFileAccessError"
        }
      }
    }, 
    "SearchMatch": {
      "type": "object", 
      "description": "match_type: The type of the match.\nmetadata: The metadata for the matched file or folder.\n", 
      "properties": {
        "match_type": {
          "$ref": "#/definitions/SearchMatchType"
        }, 
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      }
    }, 
    "ListFileMembersContinueError": {
      "type": "object", 
      "description": "Error for :route:`list_file_members/continue`.\nuser_error: None\naccess_error: None\ninvalid_cursor: :field:`ListFileMembersContinueArg.cursor` is invalid.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "user_error", 
            "access_error", 
            "invalid_cursor", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFileMembersContinueError"
        }, 
        "user_error": {
          "$ref": "#/definitions/SharingUserError"
        }
      }
    }, 
    "GetTemporaryLinkArg": {
      "type": "object", 
      "description": "path: The path to the file you want a temporary link to.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path to the file you want a temporary link to."
        }
      }
    }, 
    "GetCopyReferenceError": {
      "type": "object", 
      "description": "path: None\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GetCopyReferenceError"
        }
      }
    }, 
    "AudienceRestrictingSharedFolder": {
      "type": "object", 
      "description": "Information about the shared folder that prevents the link audience for this link from being more restrictive.\nshared_folder_id: The ID of the shared folder.\nname: The name of the shared folder.\naudience: The link audience of the shared folder.\n", 
      "properties": {
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID of the shared folder."
        }, 
        "audience": {
          "$ref": "#/definitions/LinkAudience"
        }, 
        "name": {
          "type": "string", 
          "description": "The name of the shared folder."
        }
      }
    }, 
    "GetTemporaryLinkError": {
      "type": "object", 
      "description": "path: None\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GetTemporaryLinkError"
        }
      }
    }, 
    "PollArg": {
      "type": "object", 
      "description": "Arguments for methods that poll the status of an asynchronous job.\nasync_job_id: Id of the asynchronous job. This is the value of a response returned from the method that launched the job.\n", 
      "properties": {
        "async_job_id": {
          "type": "string", 
          "description": "Id of the asynchronous job. This is the value of a response returned from the method that launched the job."
        }
      }
    }, 
    "UserInfo": {
      "type": "object", 
      "description": "Basic information about a user. Use :route:`users.get_account` and :route:`users.get_account_batch` to obtain more detailed information.\naccount_id: The account ID of the user.\nemail: Email address of user.\ndisplay_name: The display name of the user.\nsame_team: If the user is in the same team as current user.\nteam_member_id: The team member ID of the shared folder member. Only present if :field:`same_team` is true.\n", 
      "properties": {
        "email": {
          "type": "string", 
          "description": "Email address of user."
        }, 
        "team_member_id": {
          "type": "string", 
          "description": "The team member ID of the shared folder member. Only present if :field:`same_team` is true."
        }, 
        "display_name": {
          "type": "string", 
          "description": "The display name of the user."
        }, 
        "account_id": {
          "type": "string", 
          "description": "The account ID of the user."
        }, 
        "same_team": {
          "type": "boolean", 
          "description": "If the user is in the same team as current user."
        }
      }
    }, 
    "UploadErrorWithProperties": {
      "type": "object", 
      "description": "path: Unable to save the uploaded contents to a file.\nproperties_error: The supplied property group is invalid. The file has uploaded without property groups.\nother: None\n", 
      "properties": {
        "properties_error": {
          "$ref": "#/definitions/InvalidPropertyGroupError"
        }, 
        "path": {
          "$ref": "#/definitions/UploadWriteFailed"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "properties_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UploadErrorWithProperties"
        }
      }
    }, 
    "AccessLevel": {
      "type": "object", 
      "description": "Defines the access levels for collaborators.\nowner: The collaborator is the owner of the shared folder. Owners can view and edit the shared folder as well as set the folder's policies using :route:`update_folder_policy`.\neditor: The collaborator can both view and edit the shared folder.\nviewer: The collaborator can only view the shared folder.\nviewer_no_comment: The collaborator can only view the shared folder and does not have any access to comments.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "owner", 
            "editor", 
            "viewer", 
            "viewer_no_comment", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of AccessLevel"
        }
      }
    }, 
    "ThumbnailFormat": {
      "type": "object", 
      "description": "jpeg: None\npng: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "jpeg", 
            "png"
          ], 
          "type": "string", 
          "title": "Choice of ThumbnailFormat"
        }
      }
    }, 
    "CreateSharedLinkArg": {
      "type": "object", 
      "description": "path: The path to share.\nshort_url: Whether to return a shortened URL.\npending_upload: If it's okay to share a path that does not yet exist, set this to either :field:`PendingUploadMode.file` or :field:`PendingUploadMode.folder` to indicate whether to assume it's a file or folder.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path to share."
        }, 
        "pending_upload": {
          "$ref": "#/definitions/PendingUploadMode"
        }, 
        "short_url": {
          "type": "boolean", 
          "description": "Whether to return a shortened URL."
        }
      }
    }, 
    "ShareFolderError": {
      "type": "object", 
      "description": "email_unverified: The current user's e-mail address is unverified.\nbad_path: :field:`ShareFolderArg.path` is invalid.\nteam_policy_disallows_member_policy: Team policy is more restrictive than :field:`ShareFolderArg.member_policy`.\ndisallowed_shared_link_policy: The current user's account is not allowed to select the specified :field:`ShareFolderArg.shared_link_policy`.\nother: None\nno_permission: The current user does not have permission to perform this action.\n", 
      "properties": {
        "bad_path": {
          "$ref": "#/definitions/SharePathError"
        }, 
        ".tag": {
          "enum": [
            "email_unverified", 
            "bad_path", 
            "team_policy_disallows_member_policy", 
            "disallowed_shared_link_policy", 
            "other", 
            "no_permission"
          ], 
          "type": "string", 
          "title": "Choice of ShareFolderError"
        }
      }
    }, 
    "GetAccountArg": {
      "type": "object", 
      "description": "account_id: A user's account identifier.\n", 
      "properties": {
        "account_id": {
          "type": "string", 
          "description": "A user's account identifier."
        }
      }
    }, 
    "SymlinkInfo": {
      "type": "object", 
      "description": "target: The target this symlink points to.\n", 
      "properties": {
        "target": {
          "type": "string", 
          "description": "The target this symlink points to."
        }
      }
    }, 
    "SharingUserError": {
      "type": "object", 
      "description": "User account had a problem preventing this action.\nemail_unverified: The current user must verify the account e-mail address before performing this action.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "email_unverified", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharingUserError"
        }
      }
    }, 
    "SharedFolderAccessError": {
      "type": "object", 
      "description": "There is an error accessing the shared folder.\ninvalid_id: This shared folder ID is invalid.\nnot_a_member: The user is not a member of the shared folder thus cannot access it.\nemail_unverified: Never set.\nunmounted: The shared folder is unmounted.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "invalid_id", 
            "not_a_member", 
            "email_unverified", 
            "unmounted", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharedFolderAccessError"
        }
      }
    }, 
    "FolderSharingPolicyType": {
      "type": "object", 
      "description": "The sharing policy of a Paper folder.\n\nNote: The sharing policy of subfolders is inherited from the root folder.\nteam: Everyone in your team and anyone directly invited can access this folder.\ninvite_only: Only people directly invited can access this folder.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "team", 
            "invite_only"
          ], 
          "type": "string", 
          "title": "Choice of FolderSharingPolicyType"
        }
      }
    }, 
    "GroupManagementType": {
      "type": "object", 
      "description": "The group type determines how a group is managed.\nuser_managed: A group which is managed by selected users.\ncompany_managed: A group which is managed by team admins only.\nsystem_managed: A group which is managed automatically by Dropbox.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "user_managed", 
            "company_managed", 
            "system_managed", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GroupManagementType"
        }
      }
    }, 
    "AddPaperDocUserMemberResult": {
      "type": "object", 
      "description": "Per-member result for :route:`docs/users/add`.\nmember: One of specified input members.\nresult: The outcome of the action on this member.\n", 
      "properties": {
        "member": {
          "$ref": "#/definitions/MemberSelector"
        }, 
        "result": {
          "$ref": "#/definitions/AddPaperDocUserResult"
        }
      }
    }, 
    "DocLookupError": {
      "type": "object", 
      "description": "insufficient_permissions: Your account does not have permissions to perform this action.\nother: None\ndoc_not_found: The required doc was not found.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "insufficient_permissions", 
            "other", 
            "doc_not_found"
          ], 
          "type": "string", 
          "title": "Choice of DocLookupError"
        }
      }
    }, 
    "ListFolderLongpollArg": {
      "type": "object", 
      "description": "cursor: A cursor as returned by :route:`list_folder` or :route:`list_folder/continue`. Cursors retrieved by setting :field:`ListFolderArg.include_media_info` to :val:`true` are not supported.\ntimeout: A timeout in seconds. The request will block for at most this length of time, plus up to 90 seconds of random jitter added to avoid the thundering herd problem. Care should be taken when using this parameter, as some network infrastructure does not support long timeouts.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "A cursor as returned by :route:`list_folder` or :route:`list_folder/continue`. Cursors retrieved by setting :field:`ListFolderArg.include_media_info` to :val:`true` are not supported."
        }, 
        "timeout": {
          "type": "number", 
          "description": "A timeout in seconds. The request will block for at most this length of time, plus up to 90 seconds of random jitter added to avoid the thundering herd problem. Care should be taken when using this parameter, as some network infrastructure does not support long timeouts."
        }
      }
    }, 
    "UploadError": {
      "type": "object", 
      "description": "path: Unable to save the uploaded contents to a file.\nproperties_error: The supplied property group is invalid. The file has uploaded without property groups.\nother: None\n", 
      "properties": {
        "properties_error": {
          "$ref": "#/definitions/InvalidPropertyGroupError"
        }, 
        "path": {
          "$ref": "#/definitions/UploadWriteFailed"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "properties_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UploadError"
        }
      }
    }, 
    "PaperDocUpdateArgs": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\ndoc_update_policy: The policy used for the current update call.\nrevision: The latest doc revision. This value must match the head revision or an error code will be returned. This is to prevent colliding writes.\nimport_format: The format of provided data.\n", 
      "properties": {
        "doc_update_policy": {
          "$ref": "#/definitions/PaperDocUpdatePolicy"
        }, 
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }, 
        "import_format": {
          "$ref": "#/definitions/ImportFormat"
        }, 
        "revision": {
          "type": "number", 
          "description": "The latest doc revision. This value must match the head revision or an error code will be returned. This is to prevent colliding writes."
        }
      }
    }, 
    "GetFileMetadataIndividualResult": {
      "type": "object", 
      "description": "metadata: The result for this file if it was successful.\naccess_error: The result for this file if it was an error.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "metadata", 
            "access_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GetFileMetadataIndividualResult"
        }, 
        "metadata": {
          "$ref": "#/definitions/SharedFileMetadata"
        }
      }
    }, 
    "SaveCopyReferenceResult": {
      "type": "object", 
      "description": "metadata: The metadata of the saved file or folder in the user's Dropbox.\n", 
      "properties": {
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      }
    }, 
    "SaveUrlJobStatus": {
      "type": "object", 
      "description": "in_progress: The asynchronous job is still in progress.\ncomplete: Metadata of the file where the URL is saved to.\nfailed: None\n", 
      "properties": {
        "failed": {
          "$ref": "#/definitions/SaveUrlError"
        }, 
        ".tag": {
          "enum": [
            "in_progress", 
            "complete", 
            "failed"
          ], 
          "type": "string", 
          "title": "Choice of SaveUrlJobStatus"
        }, 
        "complete": {
          "$ref": "#/definitions/FileMetadata"
        }
      }
    }, 
    "GetMetadataArg": {
      "type": "object", 
      "description": "path: The path of a file or folder on Dropbox.\ninclude_media_info: If true, :field:`FileMetadata.media_info` is set for photo and video.\ninclude_deleted: If true, :type:`DeletedMetadata` will be returned for deleted file or folder, otherwise :field:`LookupError.not_found` will be returned.\ninclude_has_explicit_shared_members: If true, the results will include a flag for each file indicating whether or not  that file has any explicit members.\ninclude_property_groups: If set to a valid list of template IDs, :field:`FileMetadata.property_groups` is set if there exists property data associated with the file and each of the listed templates.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path of a file or folder on Dropbox."
        }, 
        "include_has_explicit_shared_members": {
          "type": "boolean", 
          "description": "If true, the results will include a flag for each file indicating whether or not  that file has any explicit members."
        }, 
        "include_property_groups": {
          "$ref": "#/definitions/TemplateFilterBase"
        }, 
        "include_deleted": {
          "type": "boolean", 
          "description": "If true, :type:`DeletedMetadata` will be returned for deleted file or folder, otherwise :field:`LookupError.not_found` will be returned."
        }, 
        "include_media_info": {
          "type": "boolean", 
          "description": "If true, :field:`FileMetadata.media_info` is set for photo and video."
        }
      }
    }, 
    "SharedFolderMemberPolicy": {
      "type": "object", 
      "description": "Policy governing who can be a member of a folder shared by a team member.\nteam: Only a teammate can be a member of a folder shared by a team member.\nanyone: Anyone can be a member of a folder shared by a team member.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "team", 
            "anyone", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharedFolderMemberPolicy"
        }
      }
    }, 
    "GetTemplateArg": {
      "type": "object", 
      "description": "template_id: An identifier for template added by route  See :route:`templates/add_for_user` or :route:`templates/add_for_team`.\n", 
      "properties": {
        "template_id": {
          "type": "string", 
          "description": "An identifier for template added by route  See :route:`templates/add_for_user` or :route:`templates/add_for_team`."
        }
      }
    }, 
    "RestoreError": {
      "type": "object", 
      "description": "path_lookup: An error occurs when downloading metadata for the file.\npath_write: An error occurs when trying to restore the file to that path.\ninvalid_revision: The revision is invalid. It may point to a different file.\nother: None\n", 
      "properties": {
        "path_lookup": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path_lookup", 
            "path_write", 
            "invalid_revision", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of RestoreError"
        }, 
        "path_write": {
          "$ref": "#/definitions/WriteError"
        }
      }
    }, 
    "RelocationBatchResult": {
      "type": "object", 
      "description": "entries: None\n", 
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/RelocationBatchResultData"
          }, 
          "type": "array"
        }
      }
    }, 
    "FileMemberActionResult": {
      "type": "object", 
      "description": "Per-member result for :route:`add_file_member` or :route:`change_file_member_access`.\nmember: One of specified input members.\nresult: The outcome of the action on this member.\n", 
      "properties": {
        "member": {
          "$ref": "#/definitions/MemberSelector"
        }, 
        "result": {
          "$ref": "#/definitions/FileMemberActionIndividualResult"
        }
      }
    }, 
    "ModifySharedLinkSettingsError": {
      "type": "object", 
      "description": "shared_link_not_found: The shared link wasn't found.\nshared_link_access_denied: The caller is not allowed to access this shared link.\nunsupported_link_type: This type of link is not supported.\nother: None\nsettings_error: There is an error with the given settings.\nemail_not_verified: The caller's email should be verified.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "shared_link_not_found", 
            "shared_link_access_denied", 
            "unsupported_link_type", 
            "other", 
            "settings_error", 
            "email_not_verified"
          ], 
          "type": "string", 
          "title": "Choice of ModifySharedLinkSettingsError"
        }, 
        "settings_error": {
          "$ref": "#/definitions/SharedLinkSettingsError"
        }
      }
    }, 
    "UpdateFileRequestArgs": {
      "type": "object", 
      "description": "Arguments for :route:`update`.\nid: The ID of the file request to update.\ntitle: The new title of the file request. Must not be empty.\ndestination: The new path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder permission, this will be relative to the app folder.\ndeadline: The new deadline for the file request.\nopen: Whether to set this file request as open or closed.\n", 
      "properties": {
        "open": {
          "type": "boolean", 
          "description": "Whether to set this file request as open or closed."
        }, 
        "destination": {
          "type": "string", 
          "description": "The new path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder permission, this will be relative to the app folder."
        }, 
        "deadline": {
          "$ref": "#/definitions/UpdateFileRequestDeadline"
        }, 
        "id": {
          "type": "string", 
          "description": "The ID of the file request to update."
        }, 
        "title": {
          "type": "string", 
          "description": "The new title of the file request. Must not be empty."
        }
      }
    }, 
    "TokenFromOAuth1Result": {
      "type": "object", 
      "description": "oauth2_token: The OAuth 2.0 token generated from the supplied OAuth 1.0 token.\n", 
      "properties": {
        "oauth2_token": {
          "type": "string", 
          "description": "The OAuth 2.0 token generated from the supplied OAuth 1.0 token."
        }
      }
    }, 
    "Folder": {
      "type": "object", 
      "description": "Data structure representing a Paper folder.\nid: Paper folder ID. This ID uniquely identifies the folder.\nname: Paper folder name.\n", 
      "properties": {
        "id": {
          "type": "string", 
          "description": "Paper folder ID. This ID uniquely identifies the folder."
        }, 
        "name": {
          "type": "string", 
          "description": "Paper folder name."
        }
      }
    }, 
    "RelinquishFolderMembershipArg": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\nleave_a_copy: Keep a copy of the folder's contents upon relinquishing membership.\n", 
      "properties": {
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }, 
        "leave_a_copy": {
          "type": "boolean", 
          "description": "Keep a copy of the folder's contents upon relinquishing membership."
        }
      }
    }, 
    "SaveUrlError": {
      "type": "object", 
      "description": "path: None\ndownload_failed: Failed downloading the given URL.\ninvalid_url: The given URL is invalid.\nnot_found: The file where the URL is saved to no longer exists.\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/WriteError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "download_failed", 
            "invalid_url", 
            "not_found", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SaveUrlError"
        }
      }
    }, 
    "SharingPolicy": {
      "type": "object", 
      "description": "Sharing policy of Paper doc.\npublic_sharing_policy: This value applies to the non-team members.\nteam_sharing_policy: This value applies to the team members only. The value is null for all personal accounts.\n", 
      "properties": {
        "team_sharing_policy": {
          "$ref": "#/definitions/SharingTeamPolicyType"
        }, 
        "public_sharing_policy": {
          "$ref": "#/definitions/SharingPublicPolicyType"
        }
      }
    }, 
    "LinkAudience": {
      "type": "object", 
      "description": "public: Link is accessible by anyone.\nteam: Link is accessible only by team members.\nmembers: Link is accessible only by members of the content.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "public", 
            "team", 
            "members", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of LinkAudience"
        }
      }
    }, 
    "SharedLinkAccessFailureReason": {
      "type": "object", 
      "description": "login_required: User is not logged in.\nemail_verify_required: User's email is not verified.\npassword_required: The link is password protected.\nteam_only: Access is allowed for team members only.\nowner_only: Access is allowed for the shared link's owner only.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "login_required", 
            "email_verify_required", 
            "password_required", 
            "team_only", 
            "owner_only", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharedLinkAccessFailureReason"
        }
      }
    }, 
    "PropertiesSearchQuery": {
      "type": "object", 
      "description": "query: The property field value for which to search across templates.\nmode: The mode with which to perform the search.\nlogical_operator: The logical operator with which to append the query.\n", 
      "properties": {
        "query": {
          "type": "string", 
          "description": "The property field value for which to search across templates."
        }, 
        "logical_operator": {
          "$ref": "#/definitions/LogicalOperator"
        }, 
        "mode": {
          "$ref": "#/definitions/PropertiesSearchMode"
        }
      }
    }, 
    "PropertyGroupUpdate": {
      "type": "object", 
      "description": "template_id: A unique identifier for a property template.\nadd_or_update_fields: Property fields to update. If the property field already exists, it is updated. If the property field doesn't exist, the property group is added.\nremove_fields: Property fields to remove (by name), provided they exist.\n", 
      "properties": {
        "remove_fields": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "Property fields to remove (by name), provided they exist."
        }, 
        "template_id": {
          "type": "string", 
          "description": "A unique identifier for a property template."
        }, 
        "add_or_update_fields": {
          "items": {
            "$ref": "#/definitions/PropertyField"
          }, 
          "type": "array", 
          "description": "Property fields to update. If the property field already exists, it is updated. If the property field doesn't exist, the property group is added."
        }
      }
    }, 
    "ExportFormat": {
      "type": "object", 
      "description": "The desired export format of the Paper doc.\nhtml: The HTML export format.\nmarkdown: The markdown export format.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "html", 
            "markdown", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ExportFormat"
        }
      }
    }, 
    "FileSharingInfo": {
      "type": "object", 
      "description": "Sharing info for a file which is contained by a shared folder.\nread_only: True if the file or folder is inside a read-only shared folder.\nparent_shared_folder_id: ID of shared folder that holds this file.\nmodified_by: The last user who modified the file. This field will be null if the user's account has been deleted.\n", 
      "properties": {
        "read_only": {
          "type": "boolean", 
          "description": "True if the file or folder is inside a read-only shared folder."
        }, 
        "parent_shared_folder_id": {
          "type": "string", 
          "description": "ID of shared folder that holds this file."
        }, 
        "modified_by": {
          "type": "string", 
          "description": "The last user who modified the file. This field will be null if the user's account has been deleted."
        }
      }
    }, 
    "SharedLink": {
      "type": "object", 
      "description": "url: Shared link url.\npassword: Password for the shared link.\n", 
      "properties": {
        "url": {
          "type": "string", 
          "description": "Shared link url."
        }, 
        "password": {
          "type": "string", 
          "description": "Password for the shared link."
        }
      }
    }, 
    "PaperDocCreateArgs": {
      "type": "object", 
      "description": "import_format: The format of provided data.\nparent_folder_id: The Paper folder ID where the Paper document should be created. The API user has to have write access to this folder or error is thrown.\n", 
      "properties": {
        "parent_folder_id": {
          "type": "string", 
          "description": "The Paper folder ID where the Paper document should be created. The API user has to have write access to this folder or error is thrown."
        }, 
        "import_format": {
          "$ref": "#/definitions/ImportFormat"
        }
      }
    }, 
    "Name": {
      "type": "object", 
      "description": "Representations for a person's name to assist with internationalization.\ngiven_name: Also known as a first name.\nsurname: Also known as a last name or family name.\nfamiliar_name: Locale-dependent name. In the US, a person's familiar name is their :field:`given_name`, but elsewhere, it could be any combination of a person's :field:`given_name` and :field:`surname`.\ndisplay_name: A name that can be used directly to represent the name of a user's Dropbox account.\nabbreviated_name: An abbreviated form of the person's name. Their initials in most locales.\n", 
      "properties": {
        "familiar_name": {
          "type": "string", 
          "description": "Locale-dependent name. In the US, a person's familiar name is their :field:`given_name`, but elsewhere, it could be any combination of a person's :field:`given_name` and :field:`surname`."
        }, 
        "surname": {
          "type": "string", 
          "description": "Also known as a last name or family name."
        }, 
        "display_name": {
          "type": "string", 
          "description": "A name that can be used directly to represent the name of a user's Dropbox account."
        }, 
        "given_name": {
          "type": "string", 
          "description": "Also known as a first name."
        }, 
        "abbreviated_name": {
          "type": "string", 
          "description": "An abbreviated form of the person's name. Their initials in most locales."
        }
      }
    }, 
    "ParentFolderAccessInfo": {
      "type": "object", 
      "description": "Contains information about a parent folder that a member has access to.\nfolder_name: Display name for the folder.\nshared_folder_id: The identifier of the parent shared folder.\npermissions: The user's permissions for the parent shared folder.\npath: The full path to the parent shared folder relative to the acting user's root.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The full path to the parent shared folder relative to the acting user's root."
        }, 
        "shared_folder_id": {
          "type": "string", 
          "description": "The identifier of the parent shared folder."
        }, 
        "folder_name": {
          "type": "string", 
          "description": "Display name for the folder."
        }, 
        "permissions": {
          "items": {
            "$ref": "#/definitions/MemberPermission"
          }, 
          "type": "array", 
          "description": "The user's permissions for the parent shared folder."
        }
      }
    }, 
    "InvalidPropertyGroupError": {
      "type": "object", 
      "description": "template_not_found: Template does not exist for the given identifier.\nrestricted_content: You do not have permission to modify this template.\nother: None\npath: None\nunsupported_folder: This folder cannot be tagged. Tagging folders is not supported for team-owned templates.\nproperty_field_too_large: One or more of the supplied property field values is too large.\ndoes_not_fit_template: One or more of the supplied property fields does not conform to the template specifications.\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "template_not_found", 
            "restricted_content", 
            "other", 
            "path", 
            "unsupported_folder", 
            "property_field_too_large", 
            "does_not_fit_template"
          ], 
          "type": "string", 
          "title": "Choice of InvalidPropertyGroupError"
        }, 
        "template_not_found": {
          "type": "string", 
          "description": "Template does not exist for the given identifier."
        }
      }
    }, 
    "UploadSessionFinishBatchResult": {
      "type": "object", 
      "description": "entries: Commit result for each file in the batch.\n", 
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/UploadSessionFinishBatchResultEntry"
          }, 
          "type": "array", 
          "description": "Commit result for each file in the batch."
        }
      }
    }, 
    "FileMemberActionIndividualResult": {
      "type": "object", 
      "description": "success: Member was successfully removed from this file. If AccessLevel is given, the member still has access via a parent shared folder.\nmember_error: User was not able to perform this action.\n", 
      "properties": {
        "member_error": {
          "$ref": "#/definitions/FileMemberActionError"
        }, 
        ".tag": {
          "enum": [
            "success", 
            "member_error"
          ], 
          "type": "string", 
          "title": "Choice of FileMemberActionIndividualResult"
        }, 
        "success": {
          "$ref": "#/definitions/AccessLevel"
        }
      }
    }, 
    "UpdateTemplateResult": {
      "type": "object", 
      "description": "template_id: An identifier for template added by route  See :route:`templates/add_for_user` or :route:`templates/add_for_team`.\n", 
      "properties": {
        "template_id": {
          "type": "string", 
          "description": "An identifier for template added by route  See :route:`templates/add_for_user` or :route:`templates/add_for_team`."
        }
      }
    }, 
    "UpdateFolderPolicyError": {
      "type": "object", 
      "description": "access_error: None\nnot_on_team: :field:`UpdateFolderPolicyArg.member_policy` was set even though user is not on a team.\nteam_policy_disallows_member_policy: Team policy is more restrictive than :field:`ShareFolderArg.member_policy`.\ndisallowed_shared_link_policy: The current account is not allowed to select the specified :field:`ShareFolderArg.shared_link_policy`.\nno_permission: The current user does not have permission to perform this action.\nteam_folder: This action cannot be performed on a team shared folder.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "not_on_team", 
            "team_policy_disallows_member_policy", 
            "disallowed_shared_link_policy", 
            "no_permission", 
            "team_folder", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UpdateFolderPolicyError"
        }
      }
    }, 
    "GroupMembershipInfo": {
      "type": "object", 
      "description": "The information about a group member of the shared content.\naccess_type: The access type for this member.\ngroup: The information about the membership group.\npermissions: The permissions that requesting user has on this member. The set of permissions corresponds to the MemberActions in the request.\ninitials: Never set.\nis_inherited: True if the member has access from a parent folder.\n", 
      "properties": {
        "initials": {
          "type": "string", 
          "description": "Never set."
        }, 
        "permissions": {
          "items": {
            "$ref": "#/definitions/MemberPermission"
          }, 
          "type": "array", 
          "description": "The permissions that requesting user has on this member. The set of permissions corresponds to the MemberActions in the request."
        }, 
        "group": {
          "$ref": "#/definitions/GroupInfo"
        }, 
        "access_type": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "is_inherited": {
          "type": "boolean", 
          "description": "True if the member has access from a parent folder."
        }
      }
    }, 
    "AudienceExceptions": {
      "type": "object", 
      "description": "The total count and truncated list of information of content inside this folder that has a different audience than the link on this folder. This is only returned for folders.\ncount: None\nexceptions: A truncated list of some of the content that is an exception. The length of this list could be smaller than the count since it is only a sample but will not be empty as long as count is not 0.\n", 
      "properties": {
        "count": {
          "type": "number"
        }, 
        "exceptions": {
          "items": {
            "$ref": "#/definitions/AudienceExceptionContentInfo"
          }, 
          "type": "array", 
          "description": "A truncated list of some of the content that is an exception. The length of this list could be smaller than the count since it is only a sample but will not be empty as long as count is not 0."
        }
      }
    }, 
    "PropertyType": {
      "type": "object", 
      "description": "Data type of the given property field added.\nstring: The associated property field will be of type string. Unicode is supported.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "string", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PropertyType"
        }
      }
    }, 
    "AddFolderMemberError": {
      "type": "object", 
      "description": "access_error: Unable to access shared folder.\nemail_unverified: The current user's e-mail address is unverified.\nbad_member: :field:`AddFolderMemberArg.members` contains a bad invitation recipient.\ncant_share_outside_team: Your team policy does not allow sharing outside of the team.\ntoo_many_members: The value is the member limit that was reached.\ntoo_many_pending_invites: The value is the pending invite limit that was reached.\nrate_limit: The current user has hit the limit of invites they can send per day. Try again in 24 hours.\ntoo_many_invitees: The current user is trying to share with too many people at once.\ninsufficient_plan: The current user's account doesn't support this action. An example of this is when adding a read-only member. This action can only be performed by users that have upgraded to a Pro or Business plan.\nteam_folder: This action cannot be performed on a team shared folder.\nno_permission: The current user does not have permission to perform this action.\nother: None\n", 
      "properties": {
        "too_many_members": {
          "type": "number", 
          "description": "The value is the member limit that was reached."
        }, 
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "email_unverified", 
            "bad_member", 
            "cant_share_outside_team", 
            "too_many_members", 
            "too_many_pending_invites", 
            "rate_limit", 
            "too_many_invitees", 
            "insufficient_plan", 
            "team_folder", 
            "no_permission", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of AddFolderMemberError"
        }, 
        "bad_member": {
          "$ref": "#/definitions/AddMemberSelectorError"
        }, 
        "too_many_pending_invites": {
          "type": "number", 
          "description": "The value is the pending invite limit that was reached."
        }
      }
    }, 
    "RootInfo": {
      "type": "object", 
      "description": "Information about current user's root.\nroot_namespace_id: The namespace ID for user's root namespace. It will be the namespace ID of the shared team root if the user is member of a team with a separate team root. Otherwise it will be same as :field:`RootInfo.home_namespace_id`.\nhome_namespace_id: The namespace ID for user's home namespace.\n", 
      "properties": {
        "root_namespace_id": {
          "type": "string", 
          "description": "The namespace ID for user's root namespace. It will be the namespace ID of the shared team root if the user is member of a team with a separate team root. Otherwise it will be same as :field:`RootInfo.home_namespace_id`."
        }, 
        "home_namespace_id": {
          "type": "string", 
          "description": "The namespace ID for user's home namespace."
        }
      }
    }, 
    "UploadSessionFinishBatchLaunch": {
      "type": "object", 
      "description": "Result returned by :route:`upload_session/finish_batch` that may either launch an asynchronous job or complete synchronously.\nasync_job_id: This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job.\ncomplete: None\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "async_job_id", 
            "complete", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UploadSessionFinishBatchLaunch"
        }, 
        "async_job_id": {
          "type": "string", 
          "description": "This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job."
        }, 
        "complete": {
          "$ref": "#/definitions/UploadSessionFinishBatchResult"
        }
      }
    }, 
    "ListFileRequestsResult": {
      "type": "object", 
      "description": "Result for :route:`list`.\nfile_requests: The file requests owned by this user. Apps with the app folder permission will only see file requests in their app folder.\n", 
      "properties": {
        "file_requests": {
          "items": {
            "$ref": "#/definitions/FileRequest"
          }, 
          "type": "array", 
          "description": "The file requests owned by this user. Apps with the app folder permission will only see file requests in their app folder."
        }
      }
    }, 
    "ListRevisionsError": {
      "type": "object", 
      "description": "path: None\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListRevisionsError"
        }
      }
    }, 
    "FilePermission": {
      "type": "object", 
      "description": "Whether the user is allowed to take the sharing action on the file.\naction: The action that the user may wish to take on the file.\nallow: True if the user is allowed to take the action.\nreason: The reason why the user is denied the permission. Not present if the action is allowed.\n", 
      "properties": {
        "action": {
          "$ref": "#/definitions/FileAction"
        }, 
        "reason": {
          "$ref": "#/definitions/PermissionDeniedReason"
        }, 
        "allow": {
          "type": "boolean", 
          "description": "True if the user is allowed to take the action."
        }
      }
    }, 
    "ListFolderError": {
      "type": "object", 
      "description": "path: None\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFolderError"
        }
      }
    }, 
    "FileRequest": {
      "type": "object", 
      "description": "A :link:`file request https://www.dropbox.com/help/9090` for receiving files into the user's Dropbox account.\nid: The ID of the file request.\nurl: The URL of the file request.\ntitle: The title of the file request.\ncreated: When this file request was created.\nis_open: Whether or not the file request is open. If the file request is closed, it will not accept any more file submissions.\nfile_count: The number of files this file request has received.\ndestination: The path of the folder in the Dropbox where uploaded files will be sent. This can be :val:`null` if the destination was removed. For apps with the app folder permission, this will be relative to the app folder.\ndeadline: The deadline for this file request. Only set if the request has a deadline.\n", 
      "properties": {
        "title": {
          "type": "string", 
          "description": "The title of the file request."
        }, 
        "url": {
          "type": "string", 
          "description": "The URL of the file request."
        }, 
        "destination": {
          "type": "string", 
          "description": "The path of the folder in the Dropbox where uploaded files will be sent. This can be :val:`null` if the destination was removed. For apps with the app folder permission, this will be relative to the app folder."
        }, 
        "created": {
          "type": "string", 
          "description": "When this file request was created."
        }, 
        "file_count": {
          "type": "number", 
          "description": "The number of files this file request has received."
        }, 
        "deadline": {
          "$ref": "#/definitions/FileRequestDeadline"
        }, 
        "id": {
          "type": "string", 
          "description": "The ID of the file request."
        }, 
        "is_open": {
          "type": "boolean", 
          "description": "Whether or not the file request is open. If the file request is closed, it will not accept any more file submissions."
        }
      }
    }, 
    "InviteeInfoWithPermissionLevel": {
      "type": "object", 
      "description": "invitee: Email address invited to the Paper doc.\npermission_level: Permission level for the invitee.\n", 
      "properties": {
        "permission_level": {
          "$ref": "#/definitions/PaperDocPermissionLevel"
        }, 
        "invitee": {
          "$ref": "#/definitions/InviteeInfo"
        }
      }
    }, 
    "SearchError": {
      "type": "object", 
      "description": "path: None\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SearchError"
        }
      }
    }, 
    "AddPropertiesError": {
      "type": "object", 
      "description": "template_not_found: Template does not exist for the given identifier.\nrestricted_content: You do not have permission to modify this template.\nother: None\npath: None\nunsupported_folder: This folder cannot be tagged. Tagging folders is not supported for team-owned templates.\nproperty_field_too_large: One or more of the supplied property field values is too large.\ndoes_not_fit_template: One or more of the supplied property fields does not conform to the template specifications.\nproperty_group_already_exists: A property group associated with this template and file already exists.\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "template_not_found", 
            "restricted_content", 
            "other", 
            "path", 
            "unsupported_folder", 
            "property_field_too_large", 
            "does_not_fit_template", 
            "property_group_already_exists"
          ], 
          "type": "string", 
          "title": "Choice of AddPropertiesError"
        }, 
        "template_not_found": {
          "type": "string", 
          "description": "Template does not exist for the given identifier."
        }
      }
    }, 
    "DeleteArg": {
      "type": "object", 
      "description": "path: Path in the user's Dropbox to delete.\nparent_rev: Perform delete if given \"rev\" matches the existing file's latest \"rev\". This field does not support deleting a folder.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "Path in the user's Dropbox to delete."
        }, 
        "parent_rev": {
          "type": "string", 
          "description": "Perform delete if given \"rev\" matches the existing file's latest \"rev\". This field does not support deleting a folder."
        }
      }
    }, 
    "SharedLinkMetadata": {
      "type": "object", 
      "description": "The metadata of a shared link.\nurl: URL of the shared link.\nname: The linked file name (including extension). This never contains a slash.\nlink_permissions: The link's access permissions.\nid: A unique identifier for the linked file.\nexpires: Expiration time, if set. By default the link won't expire.\npath_lower: The lowercased full path in the user's Dropbox. This always starts with a slash. This field will only be present only if the linked file is in the authenticated user's  dropbox.\nteam_member_info: The team membership information of the link's owner.  This field will only be present  if the link's owner is a team member.\ncontent_owner_team_info: The team information of the content's owner. This field will only be present if the content's owner is a team member and the content's owner team is different from the link's owner team.\n", 
      "properties": {
        "name": {
          "type": "string", 
          "description": "The linked file name (including extension). This never contains a slash."
        }, 
        "url": {
          "type": "string", 
          "description": "URL of the shared link."
        }, 
        "expires": {
          "type": "string", 
          "description": "Expiration time, if set. By default the link won't expire."
        }, 
        "path_lower": {
          "type": "string", 
          "description": "The lowercased full path in the user's Dropbox. This always starts with a slash. This field will only be present only if the linked file is in the authenticated user's  dropbox."
        }, 
        "content_owner_team_info": {
          "$ref": "#/definitions/Team"
        }, 
        "link_permissions": {
          "$ref": "#/definitions/LinkPermissions"
        }, 
        "team_member_info": {
          "$ref": "#/definitions/TeamMemberInfo"
        }, 
        "id": {
          "type": "string", 
          "description": "A unique identifier for the linked file."
        }
      }
    }, 
    "AddMemberSelectorError": {
      "type": "object", 
      "description": "automatic_group: Automatically created groups can only be added to team folders.\ninvalid_dropbox_id: The value is the ID that could not be identified.\ninvalid_email: The value is the e-email address that is malformed.\nunverified_dropbox_id: The value is the ID of the Dropbox user with an unverified e-mail address.  Invite unverified users by e-mail address instead of by their Dropbox ID.\ngroup_deleted: At least one of the specified groups in :field:`AddFolderMemberArg.members` is deleted.\ngroup_not_on_team: Sharing to a group that is not on the current user's team.\nother: None\n", 
      "properties": {
        "invalid_dropbox_id": {
          "type": "string", 
          "description": "The value is the ID that could not be identified."
        }, 
        "invalid_email": {
          "type": "string", 
          "description": "The value is the e-email address that is malformed."
        }, 
        ".tag": {
          "enum": [
            "automatic_group", 
            "invalid_dropbox_id", 
            "invalid_email", 
            "unverified_dropbox_id", 
            "group_deleted", 
            "group_not_on_team", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of AddMemberSelectorError"
        }, 
        "unverified_dropbox_id": {
          "type": "string", 
          "description": "The value is the ID of the Dropbox user with an unverified e-mail address.  Invite unverified users by e-mail address instead of by their Dropbox ID."
        }
      }
    }, 
    "MemberAction": {
      "type": "object", 
      "description": "Actions that may be taken on members of a shared folder.\nleave_a_copy: Allow the member to keep a copy of the folder when removing.\nmake_editor: Make the member an editor of the folder.\nmake_owner: Make the member an owner of the folder.\nmake_viewer: Make the member a viewer of the folder.\nmake_viewer_no_comment: Make the member a viewer of the folder without commenting permissions.\nremove: Remove the member from the folder.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "leave_a_copy", 
            "make_editor", 
            "make_owner", 
            "make_viewer", 
            "make_viewer_no_comment", 
            "remove", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of MemberAction"
        }
      }
    }, 
    "ListRevisionsResult": {
      "type": "object", 
      "description": "is_deleted: If the file identified by the latest revision in the response is either deleted or moved.\nentries: The revisions for the file. Only revisions that are not deleted will show up here.\nserver_deleted: The time of deletion if the file was deleted.\n", 
      "properties": {
        "is_deleted": {
          "type": "boolean", 
          "description": "If the file identified by the latest revision in the response is either deleted or moved."
        }, 
        "server_deleted": {
          "type": "string", 
          "description": "The time of deletion if the file was deleted."
        }, 
        "entries": {
          "items": {
            "$ref": "#/definitions/FileMetadata"
          }, 
          "type": "array", 
          "description": "The revisions for the file. Only revisions that are not deleted will show up here."
        }
      }
    }, 
    "RelocationError": {
      "type": "object", 
      "description": "from_lookup: None\nfrom_write: None\nto: None\ncant_copy_shared_folder: Shared folders can't be copied.\ncant_nest_shared_folder: Your move operation would result in nested shared folders.  This is not allowed.\ncant_move_folder_into_itself: You cannot move a folder into itself.\ntoo_many_files: The operation would involve more than 10,000 files and folders.\nduplicated_or_nested_paths: There are duplicated/nested paths among :field:`RelocationArg.from_path` and :field:`RelocationArg.to_path`.\ncant_transfer_ownership: Your move operation would result in an ownership transfer. You may reissue the request with the field :field:`RelocationArg.allow_ownership_transfer` to true.\ninsufficient_quota: The current user does not have enough space to move or copy the files.\nother: None\n", 
      "properties": {
        "to": {
          "$ref": "#/definitions/WriteError"
        }, 
        "from_lookup": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "from_lookup", 
            "from_write", 
            "to", 
            "cant_copy_shared_folder", 
            "cant_nest_shared_folder", 
            "cant_move_folder_into_itself", 
            "too_many_files", 
            "duplicated_or_nested_paths", 
            "cant_transfer_ownership", 
            "insufficient_quota", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of RelocationError"
        }, 
        "from_write": {
          "$ref": "#/definitions/WriteError"
        }
      }
    }, 
    "LinkPassword": {
      "type": "object", 
      "description": "remove_password: Remove the currently set password for the link.\nset_password: Set a new password or change an existing password.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "remove_password", 
            "set_password", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of LinkPassword"
        }, 
        "set_password": {
          "type": "string", 
          "description": "Set a new password or change an existing password."
        }
      }
    }, 
    "UnmountFolderError": {
      "type": "object", 
      "description": "access_error: None\nno_permission: The current user does not have permission to perform this action.\nnot_unmountable: The shared folder can't be unmounted. One example where this can occur is when the shared folder's parent folder is also a shared folder that resides in the current user's Dropbox.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "no_permission", 
            "not_unmountable", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UnmountFolderError"
        }
      }
    }, 
    "GroupType": {
      "type": "object", 
      "description": "The group type determines how a group is created and managed.\nteam: A group to which team members are automatically added. Applicable to :link:`team folders https://www.dropbox.com/help/986` only.\nuser_managed: A group is created and managed by a user.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "team", 
            "user_managed", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GroupType"
        }
      }
    }, 
    "ThumbnailArg": {
      "type": "object", 
      "description": "path: The path to the image file you want to thumbnail.\nformat: The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg should be preferred, while png is  better for screenshots and digital arts.\nsize: The size for the thumbnail image.\nmode: How to resize and crop the image to achieve the desired size.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path to the image file you want to thumbnail."
        }, 
        "size": {
          "$ref": "#/definitions/ThumbnailSize"
        }, 
        "mode": {
          "$ref": "#/definitions/ThumbnailMode"
        }, 
        "format": {
          "$ref": "#/definitions/ThumbnailFormat"
        }
      }
    }, 
    "ListSharedLinksArg": {
      "type": "object", 
      "description": "path: See :route:`list_shared_links` description.\ncursor: The cursor returned by your last call to :route:`list_shared_links`.\ndirect_only: See :route:`list_shared_links` description.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "The cursor returned by your last call to :route:`list_shared_links`."
        }, 
        "path": {
          "type": "string", 
          "description": "See :route:`list_shared_links` description."
        }, 
        "direct_only": {
          "type": "boolean", 
          "description": "See :route:`list_shared_links` description."
        }
      }
    }, 
    "ListFileMembersError": {
      "type": "object", 
      "description": "Error for :route:`list_file_members`.\nuser_error: None\naccess_error: None\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "user_error", 
            "access_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFileMembersError"
        }, 
        "user_error": {
          "$ref": "#/definitions/SharingUserError"
        }
      }
    }, 
    "UnshareFileArg": {
      "type": "object", 
      "description": "Arguments for :route:`unshare_file`.\nfile: The file to unshare.\n", 
      "properties": {
        "file": {
          "type": "string", 
          "description": "The file to unshare."
        }
      }
    }, 
    "PaperDocCreateError": {
      "type": "object", 
      "description": "insufficient_permissions: Your account does not have permissions to perform this action.\nother: None\ncontent_malformed: The provided content was malformed and cannot be imported to Paper.\nfolder_not_found: The specified Paper folder is cannot be found.\ndoc_length_exceeded: The newly created Paper doc would be too large. Please split the content into multiple docs.\nimage_size_exceeded: The imported document contains an image that is too large. The current limit is 1MB. Note: This only applies to HTML with data uri.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "insufficient_permissions", 
            "other", 
            "content_malformed", 
            "folder_not_found", 
            "doc_length_exceeded", 
            "image_size_exceeded"
          ], 
          "type": "string", 
          "title": "Choice of PaperDocCreateError"
        }
      }
    }, 
    "PropertiesSearchArg": {
      "type": "object", 
      "description": "queries: Queries to search.\ntemplate_filter: Filter results to contain only properties associated with these template IDs.\n", 
      "properties": {
        "template_filter": {
          "$ref": "#/definitions/TemplateFilter"
        }, 
        "queries": {
          "items": {
            "$ref": "#/definitions/PropertiesSearchQuery"
          }, 
          "type": "array", 
          "description": "Queries to search."
        }
      }
    }, 
    "FileMetadata": {
      "type": "object", 
      "description": "name: The last component of the path (including extension). This never contains a slash.\nid: A unique identifier for the file.\nclient_modified: For files, this is the modification time set by the desktop client when the file was added to Dropbox. Since this time is not verified (the Dropbox server stores whatever the desktop client sends up), this should only be used for display purposes (such as sorting) and not, for example, to determine if a file has changed or not.\nserver_modified: The last time the file was modified on Dropbox.\nrev: A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API and can be used to detect changes and avoid conflicts.\nsize: The file size in bytes.\npath_lower: The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if the file or folder is not mounted.\npath_display: The cased path to be used for display purposes only. In rare instances the casing will not correctly match the user's filesystem, but this behavior will match the path provided in the Core API v1, and at least the last path component will have the correct casing. Changes to only the casing of paths won't be returned by :route:`list_folder/continue`. This field will be null if the file or folder is not mounted.\nparent_shared_folder_id: Please use :field:`FileSharingInfo.parent_shared_folder_id` or :field:`FolderSharingInfo.parent_shared_folder_id` instead.\nmedia_info: Additional information if the file is a photo or video.\nsymlink_info: Set if this file is a symlink.\nsharing_info: Set if this file is contained in a shared folder.\nproperty_groups: Additional information if the file has custom properties with the property template specified.\nhas_explicit_shared_members: This flag will only be present if include_has_explicit_shared_members  is true in :route:`list_folder` or :route:`get_metadata`. If this  flag is present, it will be true if this file has any explicit shared  members. This is different from sharing_info in that this could be true  in the case where a file has explicit members but is not contained within  a shared folder.\ncontent_hash: A hash of the file content. This field can be used to verify data integrity. For more information see our :link:`Content hash /developers/reference/content-hash` page.\n", 
      "properties": {
        "parent_shared_folder_id": {
          "type": "string", 
          "description": "Please use :field:`FileSharingInfo.parent_shared_folder_id` or :field:`FolderSharingInfo.parent_shared_folder_id` instead."
        }, 
        "name": {
          "type": "string", 
          "description": "The last component of the path (including extension). This never contains a slash."
        }, 
        "property_groups": {
          "items": {
            "$ref": "#/definitions/PropertyGroup"
          }, 
          "type": "array", 
          "description": "Additional information if the file has custom properties with the property template specified."
        }, 
        "rev": {
          "type": "string", 
          "description": "A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API and can be used to detect changes and avoid conflicts."
        }, 
        "client_modified": {
          "type": "string", 
          "description": "For files, this is the modification time set by the desktop client when the file was added to Dropbox. Since this time is not verified (the Dropbox server stores whatever the desktop client sends up), this should only be used for display purposes (such as sorting) and not, for example, to determine if a file has changed or not."
        }, 
        "symlink_info": {
          "$ref": "#/definitions/SymlinkInfo"
        }, 
        "path_display": {
          "type": "string", 
          "description": "The cased path to be used for display purposes only. In rare instances the casing will not correctly match the user's filesystem, but this behavior will match the path provided in the Core API v1, and at least the last path component will have the correct casing. Changes to only the casing of paths won't be returned by :route:`list_folder/continue`. This field will be null if the file or folder is not mounted."
        }, 
        "has_explicit_shared_members": {
          "type": "boolean", 
          "description": "This flag will only be present if include_has_explicit_shared_members  is true in :route:`list_folder` or :route:`get_metadata`. If this  flag is present, it will be true if this file has any explicit shared  members. This is different from sharing_info in that this could be true  in the case where a file has explicit members but is not contained within  a shared folder."
        }, 
        "path_lower": {
          "type": "string", 
          "description": "The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if the file or folder is not mounted."
        }, 
        "server_modified": {
          "type": "string", 
          "description": "The last time the file was modified on Dropbox."
        }, 
        "sharing_info": {
          "$ref": "#/definitions/FileSharingInfo"
        }, 
        "media_info": {
          "$ref": "#/definitions/MediaInfo"
        }, 
        "content_hash": {
          "type": "string", 
          "description": "A hash of the file content. This field can be used to verify data integrity. For more information see our :link:`Content hash /developers/reference/content-hash` page."
        }, 
        "id": {
          "type": "string", 
          "description": "A unique identifier for the file."
        }, 
        "size": {
          "type": "number", 
          "description": "The file size in bytes."
        }
      }
    }, 
    "UploadSessionStartArg": {
      "type": "object", 
      "description": "close: If true, the current session will be closed, at which point you won't be able to call :route:`upload_session/append_v2` anymore with the current session.\n", 
      "properties": {
        "close": {
          "type": "boolean", 
          "description": "If true, the current session will be closed, at which point you won't be able to call :route:`upload_session/append_v2` anymore with the current session."
        }
      }
    }, 
    "SearchArg": {
      "type": "object", 
      "description": "path: The path in the user's Dropbox to search. Should probably be a folder.\nquery: The string to search for. The search string is split on spaces into multiple tokens. For file name searching, the last token is used for prefix matching (i.e. \"bat c\" matches \"bat cave\" but not \"batman car\").\nstart: The starting index within the search results (used for paging).\nmax_results: The maximum number of search results to return.\nmode: The search mode (filename, filename_and_content, or deleted_filename). Note that searching file content is only available for Dropbox Business accounts.\n", 
      "properties": {
        "start": {
          "type": "number", 
          "description": "The starting index within the search results (used for paging)."
        }, 
        "max_results": {
          "type": "number", 
          "description": "The maximum number of search results to return."
        }, 
        "path": {
          "type": "string", 
          "description": "The path in the user's Dropbox to search. Should probably be a folder."
        }, 
        "mode": {
          "$ref": "#/definitions/SearchMode"
        }, 
        "query": {
          "type": "string", 
          "description": "The string to search for. The search string is split on spaces into multiple tokens. For file name searching, the last token is used for prefix matching (i.e. \"bat c\" matches \"bat cave\" but not \"batman car\")."
        }
      }
    }, 
    "RelinquishFolderMembershipError": {
      "type": "object", 
      "description": "access_error: None\nfolder_owner: The current user is the owner of the shared folder. Owners cannot relinquish membership to their own folders. Try unsharing or transferring ownership first.\nmounted: The shared folder is currently mounted.  Unmount the shared folder before relinquishing membership.\ngroup_access: The current user has access to the shared folder via a group.  You can't relinquish membership to folders shared via groups.\nteam_folder: This action cannot be performed on a team shared folder.\nno_permission: The current user does not have permission to perform this action.\nno_explicit_access: The current user only has inherited access to the shared folder.  You can't relinquish inherited membership to folders.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "folder_owner", 
            "mounted", 
            "group_access", 
            "team_folder", 
            "no_permission", 
            "no_explicit_access", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of RelinquishFolderMembershipError"
        }
      }
    }, 
    "ListFolderArg": {
      "type": "object", 
      "description": "path: A unique identifier for the file.\nrecursive: If true, the list folder operation will be applied recursively to all subfolders and the response will contain contents of all subfolders.\ninclude_media_info: If true, :field:`FileMetadata.media_info` is set for photo and video.\ninclude_deleted: If true, the results will include entries for files and folders that used to exist but were deleted.\ninclude_has_explicit_shared_members: If true, the results will include a flag for each file indicating whether or not  that file has any explicit members.\ninclude_mounted_folders: If true, the results will include entries under mounted folders which includes app folder, shared folder and team folder.\nlimit: The maximum number of results to return per request. Note: This is an approximate number and there can be slightly more entries returned in some cases.\nshared_link: A shared link to list the contents of. If the link is password-protected, the password must be provided. If this field is present, :field:`ListFolderArg.path` will be relative to root of the shared link. Only non-recursive mode is supported for shared link.\ninclude_property_groups: If set to a valid list of template IDs, :field:`FileMetadata.property_groups` is set if there exists property data associated with the file and each of the listed templates.\n", 
      "properties": {
        "shared_link": {
          "$ref": "#/definitions/SharedLink"
        }, 
        "include_property_groups": {
          "$ref": "#/definitions/TemplateFilterBase"
        }, 
        "recursive": {
          "type": "boolean", 
          "description": "If true, the list folder operation will be applied recursively to all subfolders and the response will contain contents of all subfolders."
        }, 
        "include_has_explicit_shared_members": {
          "type": "boolean", 
          "description": "If true, the results will include a flag for each file indicating whether or not  that file has any explicit members."
        }, 
        "include_deleted": {
          "type": "boolean", 
          "description": "If true, the results will include entries for files and folders that used to exist but were deleted."
        }, 
        "limit": {
          "type": "number", 
          "description": "The maximum number of results to return per request. Note: This is an approximate number and there can be slightly more entries returned in some cases."
        }, 
        "include_media_info": {
          "type": "boolean", 
          "description": "If true, :field:`FileMetadata.media_info` is set for photo and video."
        }, 
        "include_mounted_folders": {
          "type": "boolean", 
          "description": "If true, the results will include entries under mounted folders which includes app folder, shared folder and team folder."
        }, 
        "path": {
          "type": "string", 
          "description": "A unique identifier for the file."
        }
      }
    }, 
    "AddPaperDocUser": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\nmembers: User which should be added to the Paper doc. Specify only email address or Dropbox account ID.\ncustom_message: A personal message that will be emailed to each successfully added member.\nquiet: Clients should set this to true if no email message shall be sent to added users.\n", 
      "properties": {
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }, 
        "quiet": {
          "type": "boolean", 
          "description": "Clients should set this to true if no email message shall be sent to added users."
        }, 
        "members": {
          "items": {
            "$ref": "#/definitions/AddMember"
          }, 
          "type": "array", 
          "description": "User which should be added to the Paper doc. Specify only email address or Dropbox account ID."
        }, 
        "custom_message": {
          "type": "string", 
          "description": "A personal message that will be emailed to each successfully added member."
        }
      }
    }, 
    "AddMember": {
      "type": "object", 
      "description": "member: User which should be added to the Paper doc. Specify only email address or Dropbox account ID.\npermission_level: Permission for the user.\n", 
      "properties": {
        "member": {
          "$ref": "#/definitions/MemberSelector"
        }, 
        "permission_level": {
          "$ref": "#/definitions/PaperDocPermissionLevel"
        }
      }
    }, 
    "GracePeriod": {
      "type": "object", 
      "description": "one_day: None\ntwo_days: None\nseven_days: None\nthirty_days: None\nalways: None\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "one_day", 
            "two_days", 
            "seven_days", 
            "thirty_days", 
            "always", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GracePeriod"
        }
      }
    }, 
    "UserInfoWithPermissionLevel": {
      "type": "object", 
      "description": "user: User shared on the Paper doc.\npermission_level: Permission level for the user.\n", 
      "properties": {
        "permission_level": {
          "$ref": "#/definitions/PaperDocPermissionLevel"
        }, 
        "user": {
          "$ref": "#/definitions/UserInfo"
        }
      }
    }, 
    "PollError": {
      "type": "object", 
      "description": "Error returned by methods for polling the status of asynchronous job.\ninvalid_async_job_id: The job ID is invalid.\ninternal_error: Something went wrong with the job on Dropbox's end. You'll need to verify that the action you were taking succeeded, and if not, try again. This should happen very rarely.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "invalid_async_job_id", 
            "internal_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PollError"
        }
      }
    }, 
    "DeleteBatchArg": {
      "type": "object", 
      "description": "entries: None\n", 
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/DeleteArg"
          }, 
          "type": "array"
        }
      }
    }, 
    "RelinquishFileMembershipError": {
      "type": "object", 
      "description": "access_error: None\ngroup_access: The current user has access to the shared file via a group.  You can't relinquish membership to a file shared via groups.\nno_permission: The current user does not have permission to perform this action.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "group_access", 
            "no_permission", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of RelinquishFileMembershipError"
        }
      }
    }, 
    "ListFileMembersBatchArg": {
      "type": "object", 
      "description": "Arguments for :route:`list_file_members/batch`.\nfiles: Files for which to return members.\nlimit: Number of members to return max per query. Defaults to 10 if no limit is specified.\n", 
      "properties": {
        "files": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "Files for which to return members."
        }, 
        "limit": {
          "type": "number", 
          "description": "Number of members to return max per query. Defaults to 10 if no limit is specified."
        }
      }
    }, 
    "GetThumbnailBatchResult": {
      "type": "object", 
      "description": "entries: List of files and their thumbnails.\n", 
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/GetThumbnailBatchResultEntry"
          }, 
          "type": "array", 
          "description": "List of files and their thumbnails."
        }
      }
    }, 
    "CreateFolderArg": {
      "type": "object", 
      "description": "path: Path in the user's Dropbox to create.\nautorename: If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "Path in the user's Dropbox to create."
        }, 
        "autorename": {
          "type": "boolean", 
          "description": "If there's a conflict, have the Dropbox server try to autorename the folder to avoid the conflict."
        }
      }
    }, 
    "PlatformType": {
      "type": "object", 
      "description": "Possible platforms on which a user may view content.\nweb: The content was viewed on the web.\nmobile: The content was viewed on a mobile client.\ndesktop: The content was viewed on a desktop client.\nunknown: The content was viewed on an unknown platform.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "web", 
            "mobile", 
            "desktop", 
            "unknown", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PlatformType"
        }
      }
    }, 
    "SharedContentLinkMetadata": {
      "type": "object", 
      "description": "Metadata of a shared link for a file or folder.\naudience_options: The audience options that are available for the content. Some audience options may be unavailable. For example, team_only may be unavailable if the content is not owned by a user on a team. The 'default' audience option is always available if the user can modify link settings.\ncurrent_audience: The current audience of the link.\nlink_permissions: A list of permissions for actions you can perform on the link.\npassword_protected: Whether the link is protected by a password.\nurl: The URL of the link.\naccess_level: The access level on the link for this file.\naudience_restricting_shared_folder: The shared folder that prevents the link audience for this link from being more restrictive.\nexpiry: Whether the link has an expiry set on it. A link with an expiry will have its  audience changed to members when the expiry is reached.\naudience_exceptions: The content inside this folder with link audience different than this folder's. This is only returned when an endpoint that returns metadata for a single shared folder is called, e.g. /get_folder_metadata.\n", 
      "properties": {
        "current_audience": {
          "$ref": "#/definitions/LinkAudience"
        }, 
        "url": {
          "type": "string", 
          "description": "The URL of the link."
        }, 
        "password_protected": {
          "type": "boolean", 
          "description": "Whether the link is protected by a password."
        }, 
        "audience_exceptions": {
          "$ref": "#/definitions/AudienceExceptions"
        }, 
        "expiry": {
          "type": "string", 
          "description": "Whether the link has an expiry set on it. A link with an expiry will have its  audience changed to members when the expiry is reached."
        }, 
        "access_level": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "audience_restricting_shared_folder": {
          "$ref": "#/definitions/AudienceRestrictingSharedFolder"
        }, 
        "link_permissions": {
          "items": {
            "$ref": "#/definitions/LinkPermission"
          }, 
          "type": "array", 
          "description": "A list of permissions for actions you can perform on the link."
        }, 
        "audience_options": {
          "items": {
            "$ref": "#/definitions/LinkAudience"
          }, 
          "type": "array", 
          "description": "The audience options that are available for the content. Some audience options may be unavailable. For example, team_only may be unavailable if the content is not owned by a user on a team. The 'default' audience option is always available if the user can modify link settings."
        }
      }
    }, 
    "InviteeMembershipInfo": {
      "type": "object", 
      "description": "Information about an invited member of a shared content.\naccess_type: The access type for this member.\ninvitee: Recipient of the invitation.\npermissions: The permissions that requesting user has on this member. The set of permissions corresponds to the MemberActions in the request.\ninitials: Never set.\nis_inherited: True if the member has access from a parent folder.\nuser: The user this invitation is tied to, if available.\n", 
      "properties": {
        "invitee": {
          "$ref": "#/definitions/InviteeInfo"
        }, 
        "access_type": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "user": {
          "$ref": "#/definitions/UserInfo"
        }, 
        "is_inherited": {
          "type": "boolean", 
          "description": "True if the member has access from a parent folder."
        }, 
        "initials": {
          "type": "string", 
          "description": "Never set."
        }, 
        "permissions": {
          "items": {
            "$ref": "#/definitions/MemberPermission"
          }, 
          "type": "array", 
          "description": "The permissions that requesting user has on this member. The set of permissions corresponds to the MemberActions in the request."
        }
      }
    }, 
    "GetAccountError": {
      "type": "object", 
      "description": "no_account: The specified :field:`GetAccountArg.account_id` does not exist.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "no_account", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GetAccountError"
        }
      }
    }, 
    "JobStatus": {
      "type": "object", 
      "description": "in_progress: The asynchronous job is still in progress.\ncomplete: The asynchronous job has finished.\nfailed: The asynchronous job returned an error.\n", 
      "properties": {
        "failed": {
          "$ref": "#/definitions/JobError"
        }, 
        ".tag": {
          "enum": [
            "in_progress", 
            "complete", 
            "failed"
          ], 
          "type": "string", 
          "title": "Choice of JobStatus"
        }
      }
    }, 
    "WriteConflictError": {
      "type": "object", 
      "description": "file: There's a file in the way.\nfolder: There's a folder in the way.\nfile_ancestor: There's a file at an ancestor path, so we couldn't create the required parent folders.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "file", 
            "folder", 
            "file_ancestor", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of WriteConflictError"
        }
      }
    }, 
    "LinkPermission": {
      "type": "object", 
      "description": "Permissions for actions that can be performed on a link.\naction: None\nallow: None\nreason: None\n", 
      "properties": {
        "action": {
          "$ref": "#/definitions/LinkAction"
        }, 
        "reason": {
          "$ref": "#/definitions/PermissionDeniedReason"
        }, 
        "allow": {
          "type": "boolean"
        }
      }
    }, 
    "Team": {
      "type": "object", 
      "description": "Information about a team.\nid: The team's unique ID.\nname: The name of the team.\n", 
      "properties": {
        "id": {
          "type": "string", 
          "description": "The team's unique ID."
        }, 
        "name": {
          "type": "string", 
          "description": "The name of the team."
        }
      }
    }, 
    "SaveUrlResult": {
      "type": "object", 
      "description": "async_job_id: This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job.\ncomplete: Metadata of the file where the URL is saved to.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "async_job_id", 
            "complete"
          ], 
          "type": "string", 
          "title": "Choice of SaveUrlResult"
        }, 
        "async_job_id": {
          "type": "string", 
          "description": "This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job."
        }, 
        "complete": {
          "$ref": "#/definitions/FileMetadata"
        }
      }
    }, 
    "SetAccessInheritanceArg": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\naccess_inheritance: The access inheritance settings for the folder.\n", 
      "properties": {
        "access_inheritance": {
          "$ref": "#/definitions/AccessInheritance"
        }, 
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }
      }
    }, 
    "ListFolderLongpollError": {
      "type": "object", 
      "description": "reset: Indicates that the cursor has been invalidated. Call :route:`list_folder` to obtain a new cursor.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "reset", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFolderLongpollError"
        }
      }
    }, 
    "ListFilesResult": {
      "type": "object", 
      "description": "Success results for :route:`list_received_files`.\nentries: Information about the files shared with current user.\ncursor: Cursor used to obtain additional shared files.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "Cursor used to obtain additional shared files."
        }, 
        "entries": {
          "items": {
            "$ref": "#/definitions/SharedFileMetadata"
          }, 
          "type": "array", 
          "description": "Information about the files shared with current user."
        }
      }
    }, 
    "CreateSharedLinkWithSettingsArg": {
      "type": "object", 
      "description": "path: The path to be shared by the shared link.\nsettings: The requested settings for the newly created shared link.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path to be shared by the shared link."
        }, 
        "settings": {
          "$ref": "#/definitions/SharedLinkSettings"
        }
      }
    }, 
    "ModifyTemplateError": {
      "type": "object", 
      "description": "template_not_found: Template does not exist for the given identifier.\nrestricted_content: You do not have permission to modify this template.\nother: None\nconflicting_property_names: A property field key with that name already exists in the template.\ntoo_many_properties: There are too many properties in the changed template. The maximum number of properties per template is 32.\ntoo_many_templates: There are too many templates for the team.\ntemplate_attribute_too_large: The template name, description or one or more of the property field keys is too large.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "template_not_found", 
            "restricted_content", 
            "other", 
            "conflicting_property_names", 
            "too_many_properties", 
            "too_many_templates", 
            "template_attribute_too_large"
          ], 
          "type": "string", 
          "title": "Choice of ModifyTemplateError"
        }, 
        "template_not_found": {
          "type": "string", 
          "description": "Template does not exist for the given identifier."
        }
      }
    }, 
    "GetFileMetadataBatchArg": {
      "type": "object", 
      "description": "Arguments of :route:`get_file_metadata/batch`.\nfiles: The files to query.\nactions: A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's :field:`SharedFileMetadata.permissions` field describing the actions the  authenticated user can perform on the file.\n", 
      "properties": {
        "files": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "The files to query."
        }, 
        "actions": {
          "items": {
            "$ref": "#/definitions/FileAction"
          }, 
          "type": "array", 
          "description": "A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's :field:`SharedFileMetadata.permissions` field describing the actions the  authenticated user can perform on the file."
        }
      }
    }, 
    "PropertiesSearchContinueArg": {
      "type": "object", 
      "description": "cursor: The cursor returned by your last call to :route:`properties/search` or :route:`properties/search/continue`.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "The cursor returned by your last call to :route:`properties/search` or :route:`properties/search/continue`."
        }
      }
    }, 
    "GetFileMetadataArg": {
      "type": "object", 
      "description": "Arguments of :route:`get_file_metadata`.\nfile: The file to query.\nactions: A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's :field:`SharedFileMetadata.permissions` field describing the actions the  authenticated user can perform on the file.\n", 
      "properties": {
        "actions": {
          "items": {
            "$ref": "#/definitions/FileAction"
          }, 
          "type": "array", 
          "description": "A list of `FileAction`s corresponding to `FilePermission`s that should appear in the  response's :field:`SharedFileMetadata.permissions` field describing the actions the  authenticated user can perform on the file."
        }, 
        "file": {
          "type": "string", 
          "description": "The file to query."
        }
      }
    }, 
    "AddFolderMemberArg": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\nmembers: The intended list of members to add.  Added members will receive invites to join the shared folder.\nquiet: Whether added members should be notified via email and device notifications of their invite.\ncustom_message: Optional message to display to added members in their invitation.\n", 
      "properties": {
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }, 
        "quiet": {
          "type": "boolean", 
          "description": "Whether added members should be notified via email and device notifications of their invite."
        }, 
        "members": {
          "items": {
            "$ref": "#/definitions/AddMember"
          }, 
          "type": "array", 
          "description": "The intended list of members to add.  Added members will receive invites to join the shared folder."
        }, 
        "custom_message": {
          "type": "string", 
          "description": "Optional message to display to added members in their invitation."
        }
      }
    }, 
    "UpdateFileMemberArgs": {
      "type": "object", 
      "description": "Arguments for :route:`update_file_member`.\nfile: File for which we are changing a member's access.\nmember: The member whose access we are changing.\naccess_level: The new access level for the member.\n", 
      "properties": {
        "member": {
          "$ref": "#/definitions/MemberSelector"
        }, 
        "access_level": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "file": {
          "type": "string", 
          "description": "File for which we are changing a member's access."
        }
      }
    }, 
    "SpaceUsage": {
      "type": "object", 
      "description": "Information about a user's space usage and quota.\nused: The user's total space usage (bytes).\nallocation: The user's space allocation.\n", 
      "properties": {
        "allocation": {
          "$ref": "#/definitions/SpaceAllocation"
        }, 
        "used": {
          "type": "number", 
          "description": "The user's total space usage (bytes)."
        }
      }
    }, 
    "CreateFolderBatchResultEntry": {
      "type": "object", 
      "description": "success: None\nfailure: None\n", 
      "properties": {
        "failure": {
          "$ref": "#/definitions/CreateFolderEntryError"
        }, 
        ".tag": {
          "enum": [
            "success", 
            "failure"
          ], 
          "type": "string", 
          "title": "Choice of CreateFolderBatchResultEntry"
        }, 
        "success": {
          "$ref": "#/definitions/CreateFolderEntryResult"
        }
      }
    }, 
    "UpdateFolderMemberError": {
      "type": "object", 
      "description": "access_error: None\nmember_error: None\nno_explicit_access: If updating the access type required the member to be added to the shared folder and there was an error when adding the member.\ninsufficient_plan: The current user's account doesn't support this action. An example of this is when downgrading a member from editor to viewer. This action can only be performed by users that have upgraded to a Pro or Business plan.\nno_permission: The current user does not have permission to perform this action.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "member_error", 
            "no_explicit_access", 
            "insufficient_plan", 
            "no_permission", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UpdateFolderMemberError"
        }, 
        "no_explicit_access": {
          "$ref": "#/definitions/AddFolderMemberError"
        }, 
        "member_error": {
          "$ref": "#/definitions/SharedFolderMemberError"
        }
      }
    }, 
    "PaperDocExportResult": {
      "type": "object", 
      "description": "owner: The Paper doc owner's email address.\ntitle: The Paper doc title.\nrevision: The Paper doc revision. Simply an ever increasing number.\nmime_type: MIME type of the export. This corresponds to :type:`ExportFormat` specified in the request.\n", 
      "properties": {
        "owner": {
          "type": "string", 
          "description": "The Paper doc owner's email address."
        }, 
        "revision": {
          "type": "number", 
          "description": "The Paper doc revision. Simply an ever increasing number."
        }, 
        "mime_type": {
          "type": "string", 
          "description": "MIME type of the export. This corresponds to :type:`ExportFormat` specified in the request."
        }, 
        "title": {
          "type": "string", 
          "description": "The Paper doc title."
        }
      }
    }, 
    "DeleteBatchError": {
      "type": "object", 
      "description": "too_many_write_operations: Use :field:`DeleteError.too_many_write_operations`. :route:`delete_batch` now provides smaller granularity about which entry has failed because of this.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "too_many_write_operations", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of DeleteBatchError"
        }
      }
    }, 
    "UserFileMembershipInfo": {
      "type": "object", 
      "description": "The information about a user member of the shared content with an appended last seen timestamp.\naccess_type: The access type for this member.\nuser: The account information for the membership user.\npermissions: The permissions that requesting user has on this member. The set of permissions corresponds to the MemberActions in the request.\ninitials: Never set.\nis_inherited: True if the member has access from a parent folder.\ntime_last_seen: The UTC timestamp of when the user has last seen the content, if they have.\nplatform_type: The platform on which the user has last seen the content, or unknown.\n", 
      "properties": {
        "access_type": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "platform_type": {
          "$ref": "#/definitions/PlatformType"
        }, 
        "user": {
          "$ref": "#/definitions/UserInfo"
        }, 
        "time_last_seen": {
          "type": "string", 
          "description": "The UTC timestamp of when the user has last seen the content, if they have."
        }, 
        "is_inherited": {
          "type": "boolean", 
          "description": "True if the member has access from a parent folder."
        }, 
        "permissions": {
          "items": {
            "$ref": "#/definitions/MemberPermission"
          }, 
          "type": "array", 
          "description": "The permissions that requesting user has on this member. The set of permissions corresponds to the MemberActions in the request."
        }, 
        "initials": {
          "type": "string", 
          "description": "Never set."
        }
      }
    }, 
    "MemberAccessLevelResult": {
      "type": "object", 
      "description": "Contains information about a member's access level to content after an operation.\naccess_level: The member still has this level of access to the content through a parent folder.\nwarning: A localized string with additional information about why the user has this access level to the content.\naccess_details: The parent folders that a member has access to. The field is present if the user has access to the first parent folder where the member gains access.\n", 
      "properties": {
        "access_level": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "access_details": {
          "items": {
            "$ref": "#/definitions/ParentFolderAccessInfo"
          }, 
          "type": "array", 
          "description": "The parent folders that a member has access to. The field is present if the user has access to the first parent folder where the member gains access."
        }, 
        "warning": {
          "type": "string", 
          "description": "A localized string with additional information about why the user has this access level to the content."
        }
      }
    }, 
    "JobError": {
      "type": "object", 
      "description": "Error occurred while performing an asynchronous job from :route:`unshare_folder` or :route:`remove_folder_member`.\nunshare_folder_error: Error occurred while performing :route:`unshare_folder` action.\nremove_folder_member_error: Error occurred while performing :route:`remove_folder_member` action.\nrelinquish_folder_membership_error: Error occurred while performing :route:`relinquish_folder_membership` action.\nother: None\n", 
      "properties": {
        "remove_folder_member_error": {
          "$ref": "#/definitions/RemoveFolderMemberError"
        }, 
        "unshare_folder_error": {
          "$ref": "#/definitions/UnshareFolderError"
        }, 
        ".tag": {
          "enum": [
            "unshare_folder_error", 
            "remove_folder_member_error", 
            "relinquish_folder_membership_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of JobError"
        }, 
        "relinquish_folder_membership_error": {
          "$ref": "#/definitions/RelinquishFolderMembershipError"
        }
      }
    }, 
    "PreviewError": {
      "type": "object", 
      "description": "path: An error occurs when downloading metadata for the file.\nin_progress: This preview generation is still in progress and the file is not ready  for preview yet.\nunsupported_extension: The file extension is not supported preview generation.\nunsupported_content: The file content is not supported for preview generation.\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "in_progress", 
            "unsupported_extension", 
            "unsupported_content"
          ], 
          "type": "string", 
          "title": "Choice of PreviewError"
        }
      }
    }, 
    "CreateFileRequestError": {
      "type": "object", 
      "description": "There was an error creating the file request.\ndisabled_for_team: This user's Dropbox Business team doesn't allow file requests.\nother: None\nnot_found: This file request ID was not found.\nnot_a_folder: The specified path is not a folder.\napp_lacks_access: This file request is not accessible to this app. Apps with the app folder permission can only access file requests in their app folder.\nno_permission: This user doesn't have permission to access or modify this file request.\nemail_unverified: This user's email address is not verified. File requests are only available on accounts with a verified email address. Users can verify their email address :link:`here https://www.dropbox.com/help/317`.\nvalidation_error: There was an error validating the request. For example, the title was invalid, or there were disallowed characters in the destination path.\ninvalid_location: File requests are not available on the specified folder.\nrate_limit: The user has reached the rate limit for creating file requests. The limit is currently 100 file requests per day.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "disabled_for_team", 
            "other", 
            "not_found", 
            "not_a_folder", 
            "app_lacks_access", 
            "no_permission", 
            "email_unverified", 
            "validation_error", 
            "invalid_location", 
            "rate_limit"
          ], 
          "type": "string", 
          "title": "Choice of CreateFileRequestError"
        }
      }
    }, 
    "SharingTeamPolicyType": {
      "type": "object", 
      "description": "The sharing policy type of the Paper doc.\npeople_with_link_can_edit: Users who have a link to this doc can edit it.\npeople_with_link_can_view_and_comment: Users who have a link to this doc can view and comment on it.\ninvite_only: Users must be explicitly invited to this doc.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "people_with_link_can_edit", 
            "people_with_link_can_view_and_comment", 
            "invite_only"
          ], 
          "type": "string", 
          "title": "Choice of SharingTeamPolicyType"
        }
      }
    }, 
    "ThumbnailSize": {
      "type": "object", 
      "description": "w32h32: 32 by 32 px.\nw64h64: 64 by 64 px.\nw128h128: 128 by 128 px.\nw256h256: 256 by 256 px.\nw480h320: 480 by 320 px.\nw640h480: 640 by 480 px.\nw960h640: 960 by 640 px.\nw1024h768: 1024 by 768 px.\nw2048h1536: 2048 by 1536 px.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "w32h32", 
            "w64h64", 
            "w128h128", 
            "w256h256", 
            "w480h320", 
            "w640h480", 
            "w960h640", 
            "w1024h768", 
            "w2048h1536"
          ], 
          "type": "string", 
          "title": "Choice of ThumbnailSize"
        }
      }
    }, 
    "UpdatePropertiesArg": {
      "type": "object", 
      "description": "path: A unique identifier for the file or folder.\nupdate_property_groups: The property groups \"delta\" updates to apply.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "A unique identifier for the file or folder."
        }, 
        "update_property_groups": {
          "items": {
            "$ref": "#/definitions/PropertyGroupUpdate"
          }, 
          "type": "array", 
          "description": "The property groups \"delta\" updates to apply."
        }
      }
    }, 
    "GetThumbnailBatchArg": {
      "type": "object", 
      "description": "Arguments for :route:`get_thumbnail_batch`.\nentries: List of files to get thumbnails.\n", 
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/ThumbnailArg"
          }, 
          "type": "array", 
          "description": "List of files to get thumbnails."
        }
      }
    }, 
    "AddFileMemberError": {
      "type": "object", 
      "description": "Errors for :route:`add_file_member`.\nuser_error: None\naccess_error: None\nrate_limit: The user has reached the rate limit for invitations.\ninvalid_comment: The custom message did not pass comment permissions checks.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "user_error", 
            "access_error", 
            "rate_limit", 
            "invalid_comment", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of AddFileMemberError"
        }, 
        "user_error": {
          "$ref": "#/definitions/SharingUserError"
        }
      }
    }, 
    "RelocationBatchArg": {
      "type": "object", 
      "description": "entries: List of entries to be moved or copied. Each entry is :type:`RelocationPath`.\nallow_shared_folder: If true, :route:`copy_batch` will copy contents in shared folder, otherwise :field:`RelocationError.cant_copy_shared_folder` will be returned if :field:`RelocationPath.from_path` contains shared folder.  This field is always true for :route:`move_batch`.\nautorename: If there's a conflict with any file, have the Dropbox server try to autorename that file to avoid the conflict.\nallow_ownership_transfer: Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does not apply to copies.\n", 
      "properties": {
        "allow_ownership_transfer": {
          "type": "boolean", 
          "description": "Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does not apply to copies."
        }, 
        "allow_shared_folder": {
          "type": "boolean", 
          "description": "If true, :route:`copy_batch` will copy contents in shared folder, otherwise :field:`RelocationError.cant_copy_shared_folder` will be returned if :field:`RelocationPath.from_path` contains shared folder.  This field is always true for :route:`move_batch`."
        }, 
        "autorename": {
          "type": "boolean", 
          "description": "If there's a conflict with any file, have the Dropbox server try to autorename that file to avoid the conflict."
        }, 
        "entries": {
          "items": {
            "$ref": "#/definitions/RelocationPath"
          }, 
          "type": "array", 
          "description": "List of entries to be moved or copied. Each entry is :type:`RelocationPath`."
        }
      }
    }, 
    "CreateFolderBatchResult": {
      "type": "object", 
      "description": "entries: None\n", 
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/CreateFolderBatchResultEntry"
          }, 
          "type": "array"
        }
      }
    }, 
    "GetSharedLinksArg": {
      "type": "object", 
      "description": "path: See :route:`get_shared_links` description.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "See :route:`get_shared_links` description."
        }
      }
    }, 
    "ListFolderMembersArgs": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\nactions: This is a list indicating whether each returned member will include a boolean value :field:`MemberPermission.allow` that describes whether the current user can perform the MemberAction on the member.\nlimit: The maximum number of results that include members, groups and invitees to return per request.\n", 
      "properties": {
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }, 
        "limit": {
          "type": "number", 
          "description": "The maximum number of results that include members, groups and invitees to return per request."
        }, 
        "actions": {
          "items": {
            "$ref": "#/definitions/MemberAction"
          }, 
          "type": "array", 
          "description": "This is a list indicating whether each returned member will include a boolean value :field:`MemberPermission.allow` that describes whether the current user can perform the MemberAction on the member."
        }
      }
    }, 
    "SaveCopyReferenceArg": {
      "type": "object", 
      "description": "copy_reference: A copy reference returned by :route:`copy_reference/get`.\npath: Path in the user's Dropbox that is the destination.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "Path in the user's Dropbox that is the destination."
        }, 
        "copy_reference": {
          "type": "string", 
          "description": "A copy reference returned by :route:`copy_reference/get`."
        }
      }
    }, 
    "PropertiesSearchContinueError": {
      "type": "object", 
      "description": "reset: Indicates that the cursor has been invalidated. Call :route:`properties/search` to obtain a new cursor.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "reset", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PropertiesSearchContinueError"
        }
      }
    }, 
    "RemoveFolderMemberArg": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\nmember: The member to remove from the folder.\nleave_a_copy: If true, the removed user will keep their copy of the folder after it's unshared, assuming it was mounted. Otherwise, it will be removed from their Dropbox. Also, this must be set to false when kicking a group.\n", 
      "properties": {
        "member": {
          "$ref": "#/definitions/MemberSelector"
        }, 
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }, 
        "leave_a_copy": {
          "type": "boolean", 
          "description": "If true, the removed user will keep their copy of the folder after it's unshared, assuming it was mounted. Otherwise, it will be removed from their Dropbox. Also, this must be set to false when kicking a group."
        }
      }
    }, 
    "TokenFromOAuth1Error": {
      "type": "object", 
      "description": "invalid_oauth1_token_info: Part or all of the OAuth 1.0 access token info is invalid.\napp_id_mismatch: The authorized app does not match the app associated with the supplied access token.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "invalid_oauth1_token_info", 
            "app_id_mismatch", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of TokenFromOAuth1Error"
        }
      }
    }, 
    "PaperApiCursorError": {
      "type": "object", 
      "description": "expired_cursor: The provided cursor is expired.\ninvalid_cursor: The provided cursor is invalid.\nwrong_user_in_cursor: The provided cursor contains invalid user.\nreset: Indicates that the cursor has been invalidated. Call the corresponding non-continue endpoint to obtain a new cursor.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "expired_cursor", 
            "invalid_cursor", 
            "wrong_user_in_cursor", 
            "reset", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PaperApiCursorError"
        }
      }
    }, 
    "GetMetadataArgs": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\nactions: A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's :field:`SharedFolderMetadata.permissions` field describing the actions the  authenticated user can perform on the folder.\n", 
      "properties": {
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }, 
        "actions": {
          "items": {
            "$ref": "#/definitions/FolderAction"
          }, 
          "type": "array", 
          "description": "A list of `FolderAction`s corresponding to `FolderPermission`s that should appear in the  response's :field:`SharedFolderMetadata.permissions` field describing the actions the  authenticated user can perform on the folder."
        }
      }
    }, 
    "GetThumbnailBatchResultData": {
      "type": "object", 
      "description": "metadata: None\nthumbnail: None\n", 
      "properties": {
        "thumbnail": {
          "type": "string"
        }, 
        "metadata": {
          "$ref": "#/definitions/FileMetadata"
        }
      }
    }, 
    "ListFolderGetLatestCursorResult": {
      "type": "object", 
      "description": "cursor: Pass the cursor into :route:`list_folder/continue` to see what's changed in the folder since your previous query.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "Pass the cursor into :route:`list_folder/continue` to see what's changed in the folder since your previous query."
        }
      }
    }, 
    "PermissionDeniedReason": {
      "type": "object", 
      "description": "Possible reasons the user is denied a permission.\nuser_not_same_team_as_owner: User is not on the same team as the folder owner.\nuser_not_allowed_by_owner: User is prohibited by the owner from taking the action.\ntarget_is_indirect_member: Target is indirectly a member of the folder, for example by being part of a group.\ntarget_is_owner: Target is the owner of the folder.\ntarget_is_self: Target is the user itself.\ntarget_not_active: Target is not an active member of the team.\nfolder_is_limited_team_folder: Folder is team folder for a limited team.\nowner_not_on_team: The content owner needs to be on a Dropbox team to perform this action.\npermission_denied: The user does not have permission to perform this action on the link.\nrestricted_by_team: The user's team policy prevents performing this action on the link.\nuser_account_type: The user's account type does not support this action.\nuser_not_on_team: The user needs to be on a Dropbox team to perform this action.\nfolder_is_inside_shared_folder: Folder is inside of another shared folder.\nrestricted_by_parent_folder: Policy cannot be changed due to restrictions from parent folder.\ninsufficient_plan: None\nother: None\n", 
      "properties": {
        "insufficient_plan": {
          "$ref": "#/definitions/InsufficientPlan"
        }, 
        ".tag": {
          "enum": [
            "user_not_same_team_as_owner", 
            "user_not_allowed_by_owner", 
            "target_is_indirect_member", 
            "target_is_owner", 
            "target_is_self", 
            "target_not_active", 
            "folder_is_limited_team_folder", 
            "owner_not_on_team", 
            "permission_denied", 
            "restricted_by_team", 
            "user_account_type", 
            "user_not_on_team", 
            "folder_is_inside_shared_folder", 
            "restricted_by_parent_folder", 
            "insufficient_plan", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PermissionDeniedReason"
        }
      }
    }, 
    "UploadSessionFinishBatchJobStatus": {
      "type": "object", 
      "description": "in_progress: The asynchronous job is still in progress.\ncomplete: The :route:`upload_session/finish_batch` has finished.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "in_progress", 
            "complete"
          ], 
          "type": "string", 
          "title": "Choice of UploadSessionFinishBatchJobStatus"
        }, 
        "complete": {
          "$ref": "#/definitions/UploadSessionFinishBatchResult"
        }
      }
    }, 
    "SharedLinkCreatePolicy": {
      "type": "object", 
      "description": "Policy governing the visibility of shared links. This policy can apply to newly created shared links, or all shared links.\ndefault_public: By default, anyone can access newly created shared links. No login will be required to access the shared links unless overridden.\ndefault_team_only: By default, only members of the same team can access newly created shared links. Login will be required to access the shared links unless overridden.\nteam_only: Only members of the same team can access all shared links. Login will be required to access all shared links.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "default_public", 
            "default_team_only", 
            "team_only", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharedLinkCreatePolicy"
        }
      }
    }, 
    "ImportFormat": {
      "type": "object", 
      "description": "The import format of the incoming data.\nhtml: The provided data is interpreted as standard HTML.\nmarkdown: The provided data is interpreted as markdown.\nNote: The first line of the provided document will be used as the doc title.\nplain_text: The provided data is interpreted as plain text.\nNote: The first line of the provided document will be used as the doc title.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "html", 
            "markdown", 
            "plain_text", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ImportFormat"
        }
      }
    }, 
    "MemberSelector": {
      "type": "object", 
      "description": "Includes different ways to identify a member of a shared folder.\ndropbox_id: Dropbox account, team member, or group ID of member.\nemail: E-mail address of member.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "dropbox_id", 
            "email", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of MemberSelector"
        }, 
        "dropbox_id": {
          "type": "string", 
          "description": "Dropbox account, team member, or group ID of member."
        }, 
        "email": {
          "type": "string", 
          "description": "E-mail address of member."
        }
      }
    }, 
    "RelocationBatchLaunch": {
      "type": "object", 
      "description": "Result returned by :route:`copy_batch` or :route:`move_batch` that may either launch an asynchronous job or complete synchronously.\nasync_job_id: This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job.\ncomplete: None\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "async_job_id", 
            "complete", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of RelocationBatchLaunch"
        }, 
        "async_job_id": {
          "type": "string", 
          "description": "This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job."
        }, 
        "complete": {
          "$ref": "#/definitions/RelocationBatchResult"
        }
      }
    }, 
    "GetFileMetadataBatchResult": {
      "type": "object", 
      "description": "Per file results of :route:`get_file_metadata/batch`.\nfile: This is the input file identifier corresponding to one of :field:`GetFileMetadataBatchArg.files`.\nresult: The result for this particular file.\n", 
      "properties": {
        "result": {
          "$ref": "#/definitions/GetFileMetadataIndividualResult"
        }, 
        "file": {
          "type": "string", 
          "description": "This is the input file identifier corresponding to one of :field:`GetFileMetadataBatchArg.files`."
        }
      }
    }, 
    "ListFilesContinueArg": {
      "type": "object", 
      "description": "Arguments for :route:`list_received_files/continue`.\ncursor: Cursor in :field:`ListFilesResult.cursor`.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "Cursor in :field:`ListFilesResult.cursor`."
        }
      }
    }, 
    "ListDocsCursorError": {
      "type": "object", 
      "description": "cursor_error: None\nother: None\n", 
      "properties": {
        "cursor_error": {
          "$ref": "#/definitions/PaperApiCursorError"
        }, 
        ".tag": {
          "enum": [
            "cursor_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListDocsCursorError"
        }
      }
    }, 
    "FileMemberActionError": {
      "type": "object", 
      "description": "invalid_member: Specified member was not found.\nno_permission: User does not have permission to perform this action on this member.\naccess_error: Specified file was invalid or user does not have access.\nno_explicit_access: The action cannot be completed because the target member does not have explicit access to the file. The return value is the access that the member has to the file from a parent folder.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "invalid_member", 
            "no_permission", 
            "access_error", 
            "no_explicit_access", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of FileMemberActionError"
        }, 
        "no_explicit_access": {
          "$ref": "#/definitions/MemberAccessLevelResult"
        }
      }
    }, 
    "TemplateFilter": {
      "type": "object", 
      "description": "filter_some: Only templates with an ID in the supplied list will be returned (a subset of templates will be returned).\nother: None\nfilter_none: No templates will be filtered from the result (all templates will be returned).\n", 
      "properties": {
        "filter_some": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "Only templates with an ID in the supplied list will be returned (a subset of templates will be returned)."
        }, 
        ".tag": {
          "enum": [
            "filter_some", 
            "other", 
            "filter_none"
          ], 
          "type": "string", 
          "title": "Choice of TemplateFilter"
        }
      }
    }, 
    "SetAccessInheritanceError": {
      "type": "object", 
      "description": "access_error: Unable to access shared folder.\nno_permission: The current user does not have permission to perform this action.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "no_permission", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SetAccessInheritanceError"
        }
      }
    }, 
    "ListFoldersContinueError": {
      "type": "object", 
      "description": "invalid_cursor: :field:`ListFoldersContinueArg.cursor` is invalid.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "invalid_cursor", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFoldersContinueError"
        }
      }
    }, 
    "AddPropertiesArg": {
      "type": "object", 
      "description": "path: A unique identifier for the file or folder.\nproperty_groups: The property groups which are to be added to a Dropbox file.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "A unique identifier for the file or folder."
        }, 
        "property_groups": {
          "items": {
            "$ref": "#/definitions/PropertyGroup"
          }, 
          "type": "array", 
          "description": "The property groups which are to be added to a Dropbox file."
        }
      }
    }, 
    "MediaInfo": {
      "type": "object", 
      "description": "pending: Indicate the photo/video is still under processing and metadata is not available yet.\nmetadata: The metadata for the photo/video.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "pending", 
            "metadata"
          ], 
          "type": "string", 
          "title": "Choice of MediaInfo"
        }, 
        "metadata": {
          "$ref": "#/definitions/MediaMetadata"
        }
      }
    }, 
    "LinkPermissions": {
      "type": "object", 
      "description": "can_revoke: Whether the caller can revoke the shared link.\nresolved_visibility: The current visibility of the link after considering the shared links policies of the the team (in case the link's owner is part of a team) and the shared folder (in case the linked file is part of a shared folder). This field is shown only if the caller has access to this info (the link's owner always has access to this data).\nrequested_visibility: The shared link's requested visibility. This can be overridden by the team and shared folder policies. The final visibility, after considering these policies, can be found in :field:`resolved_visibility`. This is shown only if the caller is the link's owner.\nrevoke_failure_reason: The failure reason for revoking the link. This field will only be present if the :field:`can_revoke` is :val:`false`.\n", 
      "properties": {
        "requested_visibility": {
          "$ref": "#/definitions/RequestedVisibility"
        }, 
        "resolved_visibility": {
          "$ref": "#/definitions/ResolvedVisibility"
        }, 
        "can_revoke": {
          "type": "boolean", 
          "description": "Whether the caller can revoke the shared link."
        }, 
        "revoke_failure_reason": {
          "$ref": "#/definitions/SharedLinkAccessFailureReason"
        }
      }
    }, 
    "DeleteBatchResultEntry": {
      "type": "object", 
      "description": "success: None\nfailure: None\n", 
      "properties": {
        "failure": {
          "$ref": "#/definitions/DeleteError"
        }, 
        ".tag": {
          "enum": [
            "success", 
            "failure"
          ], 
          "type": "string", 
          "title": "Choice of DeleteBatchResultEntry"
        }, 
        "success": {
          "$ref": "#/definitions/DeleteBatchResultData"
        }
      }
    }, 
    "PropertyGroup": {
      "type": "object", 
      "description": "A subset of the property fields described by the corresponding :type:`PropertyGroupTemplate`. Properties are always added to a Dropbox file as a :type:`PropertyGroup`. The possible key names and value types in this group are defined by the corresponding :type:`PropertyGroupTemplate`.\ntemplate_id: A unique identifier for the associated template.\nfields: The actual properties associated with the template. There can be up to 32 property types per template.\n", 
      "properties": {
        "fields": {
          "items": {
            "$ref": "#/definitions/PropertyField"
          }, 
          "type": "array", 
          "description": "The actual properties associated with the template. There can be up to 32 property types per template."
        }, 
        "template_id": {
          "type": "string", 
          "description": "A unique identifier for the associated template."
        }
      }
    }, 
    "CreateFolderBatchLaunch": {
      "type": "object", 
      "description": "Result returned by :route:`create_folder_batch` that may either launch an asynchronous job or complete synchronously.\nasync_job_id: This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job.\ncomplete: None\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "async_job_id", 
            "complete", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of CreateFolderBatchLaunch"
        }, 
        "async_job_id": {
          "type": "string", 
          "description": "This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job."
        }, 
        "complete": {
          "$ref": "#/definitions/CreateFolderBatchResult"
        }
      }
    }, 
    "ListUsersOnFolderContinueArgs": {
      "type": "object", 
      "description": "doc_id: The Paper doc ID.\ncursor: The cursor obtained from :route:`docs/folder_users/list` or :route:`docs/folder_users/list/continue`. Allows for pagination.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "The cursor obtained from :route:`docs/folder_users/list` or :route:`docs/folder_users/list/continue`. Allows for pagination."
        }, 
        "doc_id": {
          "type": "string", 
          "description": "The Paper doc ID."
        }
      }
    }, 
    "RelocationBatchError": {
      "type": "object", 
      "description": "from_lookup: None\nfrom_write: None\nto: None\ncant_copy_shared_folder: Shared folders can't be copied.\ncant_nest_shared_folder: Your move operation would result in nested shared folders.  This is not allowed.\ncant_move_folder_into_itself: You cannot move a folder into itself.\ntoo_many_files: The operation would involve more than 10,000 files and folders.\nduplicated_or_nested_paths: There are duplicated/nested paths among :field:`RelocationArg.from_path` and :field:`RelocationArg.to_path`.\ncant_transfer_ownership: Your move operation would result in an ownership transfer. You may reissue the request with the field :field:`RelocationArg.allow_ownership_transfer` to true.\ninsufficient_quota: The current user does not have enough space to move or copy the files.\nother: None\ntoo_many_write_operations: There are too many write operations in user's Dropbox. Please retry this request.\n", 
      "properties": {
        "to": {
          "$ref": "#/definitions/WriteError"
        }, 
        "from_lookup": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "from_lookup", 
            "from_write", 
            "to", 
            "cant_copy_shared_folder", 
            "cant_nest_shared_folder", 
            "cant_move_folder_into_itself", 
            "too_many_files", 
            "duplicated_or_nested_paths", 
            "cant_transfer_ownership", 
            "insufficient_quota", 
            "other", 
            "too_many_write_operations"
          ], 
          "type": "string", 
          "title": "Choice of RelocationBatchError"
        }, 
        "from_write": {
          "$ref": "#/definitions/WriteError"
        }
      }
    }, 
    "UnshareFileError": {
      "type": "object", 
      "description": "Error result for :route:`unshare_file`.\nuser_error: None\naccess_error: None\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "user_error", 
            "access_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UnshareFileError"
        }, 
        "user_error": {
          "$ref": "#/definitions/SharingUserError"
        }
      }
    }, 
    "SearchMatchType": {
      "type": "object", 
      "description": "Indicates what type of match was found for a given item.\nfilename: This item was matched on its file or folder name.\ncontent: This item was matched based on its file contents.\nboth: This item was matched based on both its contents and its file name.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "filename", 
            "content", 
            "both"
          ], 
          "type": "string", 
          "title": "Choice of SearchMatchType"
        }
      }
    }, 
    "SharedFileMembers": {
      "type": "object", 
      "description": "Shared file user, group, and invitee membership.\nUsed for the results of :route:`list_file_members` and :route:`list_file_members/continue`, and used as part of the results for :route:`list_file_members/batch`.\nusers: The list of user members of the shared file.\ngroups: The list of group members of the shared file.\ninvitees: The list of invited members of a file, but have not logged in and claimed this.\ncursor: Present if there are additional shared file members that have not been returned yet. Pass the cursor into :route:`list_file_members/continue` to list additional members.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "Present if there are additional shared file members that have not been returned yet. Pass the cursor into :route:`list_file_members/continue` to list additional members."
        }, 
        "users": {
          "items": {
            "$ref": "#/definitions/UserFileMembershipInfo"
          }, 
          "type": "array", 
          "description": "The list of user members of the shared file."
        }, 
        "groups": {
          "items": {
            "$ref": "#/definitions/GroupMembershipInfo"
          }, 
          "type": "array", 
          "description": "The list of group members of the shared file."
        }, 
        "invitees": {
          "items": {
            "$ref": "#/definitions/InviteeMembershipInfo"
          }, 
          "type": "array", 
          "description": "The list of invited members of a file, but have not logged in and claimed this."
        }
      }
    }, 
    "WriteError": {
      "type": "object", 
      "description": "malformed_path: None\nconflict: Couldn't write to the target path because there was something in the way.\nno_write_permission: The user doesn't have permissions to write to the target location.\ninsufficient_space: The user doesn't have enough available space (bytes) to write more data.\ndisallowed_name: Dropbox will not save the file or folder because of its name.\nteam_folder: This endpoint cannot move or delete team folders.\ntoo_many_write_operations: There are too many write operations in user's Dropbox. Please retry this request.\nother: None\n", 
      "properties": {
        "malformed_path": {
          "type": "string"
        }, 
        ".tag": {
          "enum": [
            "malformed_path", 
            "conflict", 
            "no_write_permission", 
            "insufficient_space", 
            "disallowed_name", 
            "team_folder", 
            "too_many_write_operations", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of WriteError"
        }, 
        "conflict": {
          "$ref": "#/definitions/WriteConflictError"
        }
      }
    }, 
    "FileAction": {
      "type": "object", 
      "description": "Sharing actions that may be taken on files.\ndisable_viewer_info: Disable viewer information on the file.\nedit_contents: Change or edit contents of the file.\nenable_viewer_info: Enable viewer information on the file.\ninvite_viewer: Add a member with view permissions.\ninvite_viewer_no_comment: Add a member with view permissions but no comment permissions.\nunshare: Stop sharing this file.\nrelinquish_membership: Relinquish one's own membership to the file.\nshare_link: Use create_link instead.\ncreate_link: Create a shared link to the file.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "disable_viewer_info", 
            "edit_contents", 
            "enable_viewer_info", 
            "invite_viewer", 
            "invite_viewer_no_comment", 
            "unshare", 
            "relinquish_membership", 
            "share_link", 
            "create_link", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of FileAction"
        }
      }
    }, 
    "PropertiesSearchMatch": {
      "type": "object", 
      "description": "id: The ID for the matched file or folder.\npath: The path for the matched file or folder.\nis_deleted: Whether the file or folder is deleted.\nproperty_groups: List of custom property groups associated with the file.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path for the matched file or folder."
        }, 
        "is_deleted": {
          "type": "boolean", 
          "description": "Whether the file or folder is deleted."
        }, 
        "id": {
          "type": "string", 
          "description": "The ID for the matched file or folder."
        }, 
        "property_groups": {
          "items": {
            "$ref": "#/definitions/PropertyGroup"
          }, 
          "type": "array", 
          "description": "List of custom property groups associated with the file."
        }
      }
    }, 
    "MemberPolicy": {
      "type": "object", 
      "description": "Policy governing who can be a member of a shared folder. Only applicable to folders owned by a user on a team.\nteam: Only a teammate can become a member.\nanyone: Anyone can become a member.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "team", 
            "anyone", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of MemberPolicy"
        }
      }
    }, 
    "UploadWriteFailed": {
      "type": "object", 
      "description": "reason: The reason why the file couldn't be saved.\nupload_session_id: The upload session ID; data has already been uploaded to the corresponding upload session and this ID may be used to retry the commit with :route:`upload_session/finish`.\n", 
      "properties": {
        "reason": {
          "$ref": "#/definitions/WriteError"
        }, 
        "upload_session_id": {
          "type": "string", 
          "description": "The upload session ID; data has already been uploaded to the corresponding upload session and this ID may be used to retry the commit with :route:`upload_session/finish`."
        }
      }
    }, 
    "LaunchEmptyResult": {
      "type": "object", 
      "description": "Result returned by methods that may either launch an asynchronous job or complete synchronously. Upon synchronous completion of the job, no additional information is returned.\nasync_job_id: This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job.\ncomplete: The job finished synchronously and successfully.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "async_job_id", 
            "complete"
          ], 
          "type": "string", 
          "title": "Choice of LaunchEmptyResult"
        }, 
        "async_job_id": {
          "type": "string", 
          "description": "This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job."
        }
      }
    }, 
    "OfficeAddInPolicy": {
      "type": "object", 
      "description": "disabled: Office Add-In is disabled.\nenabled: Office Add-In is enabled.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "disabled", 
            "enabled", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of OfficeAddInPolicy"
        }
      }
    }, 
    "PaperDocUpdateError": {
      "type": "object", 
      "description": "insufficient_permissions: Your account does not have permissions to perform this action.\nother: None\ndoc_not_found: The required doc was not found.\ncontent_malformed: The provided content was malformed and cannot be imported to Paper.\nrevision_mismatch: The provided revision does not match the document head.\ndoc_length_exceeded: The newly created Paper doc would be too large, split the content into multiple docs.\nimage_size_exceeded: The imported document contains an image that is too large. The current limit is 1MB. Note: This only applies to HTML with data uri.\ndoc_archived: This operation is not allowed on archived Paper docs.\ndoc_deleted: This operation is not allowed on deleted Paper docs.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "insufficient_permissions", 
            "other", 
            "doc_not_found", 
            "content_malformed", 
            "revision_mismatch", 
            "doc_length_exceeded", 
            "image_size_exceeded", 
            "doc_archived", 
            "doc_deleted"
          ], 
          "type": "string", 
          "title": "Choice of PaperDocUpdateError"
        }
      }
    }, 
    "UploadSessionFinishError": {
      "type": "object", 
      "description": "lookup_failed: The session arguments are incorrect; the value explains the reason.\npath: Unable to save the uploaded contents to a file. Data has already been appended to the upload session. Please retry with empty data body and updated offset.\nproperties_error: The supplied property group is invalid. The file has uploaded without property groups.\ntoo_many_shared_folder_targets: The batch request commits files into too many different shared folders. Please limit your batch request to files contained in a single shared folder.\ntoo_many_write_operations: There are too many write operations happening in the user's Dropbox. You should retry uploading this file.\nother: None\n", 
      "properties": {
        "properties_error": {
          "$ref": "#/definitions/InvalidPropertyGroupError"
        }, 
        "path": {
          "$ref": "#/definitions/WriteError"
        }, 
        ".tag": {
          "enum": [
            "lookup_failed", 
            "path", 
            "properties_error", 
            "too_many_shared_folder_targets", 
            "too_many_write_operations", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UploadSessionFinishError"
        }, 
        "lookup_failed": {
          "$ref": "#/definitions/UploadSessionLookupError"
        }
      }
    }, 
    "RemoveTemplateArg": {
      "type": "object", 
      "description": "template_id: An identifier for a template created by :route:`templates/add_for_user` or :route:`templates/add_for_team`.\n", 
      "properties": {
        "template_id": {
          "type": "string", 
          "description": "An identifier for a template created by :route:`templates/add_for_user` or :route:`templates/add_for_team`."
        }
      }
    }, 
    "ResolvedVisibility": {
      "type": "object", 
      "description": "The actual access permissions values of shared links after taking into account user preferences and the team and shared folder settings. Check the :type:`RequestedVisibility` for more info on the possible visibility values that can be set by the shared link's owner.\npublic: Anyone who has received the link can access it. No login required.\nteam_only: Only members of the same team can access the link. Login is required.\npassword: A link-specific password is required to access the link. Login is not required.\nteam_and_password: Only members of the same team who have the link-specific password can access the link. Login is required.\nshared_folder_only: Only members of the shared folder containing the linked file can access the link. Login is required.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "public", 
            "team_only", 
            "password", 
            "team_and_password", 
            "shared_folder_only", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ResolvedVisibility"
        }
      }
    }, 
    "PaperDocCreateUpdateResult": {
      "type": "object", 
      "description": "doc_id: Doc ID of the newly created doc.\nrevision: The Paper doc revision. Simply an ever increasing number.\ntitle: The Paper doc title.\n", 
      "properties": {
        "title": {
          "type": "string", 
          "description": "The Paper doc title."
        }, 
        "doc_id": {
          "type": "string", 
          "description": "Doc ID of the newly created doc."
        }, 
        "revision": {
          "type": "number", 
          "description": "The Paper doc revision. Simply an ever increasing number."
        }
      }
    }, 
    "FolderMetadata": {
      "type": "object", 
      "description": "name: The last component of the path (including extension). This never contains a slash.\nid: A unique identifier for the folder.\npath_lower: The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if the file or folder is not mounted.\npath_display: The cased path to be used for display purposes only. In rare instances the casing will not correctly match the user's filesystem, but this behavior will match the path provided in the Core API v1, and at least the last path component will have the correct casing. Changes to only the casing of paths won't be returned by :route:`list_folder/continue`. This field will be null if the file or folder is not mounted.\nparent_shared_folder_id: Please use :field:`FileSharingInfo.parent_shared_folder_id` or :field:`FolderSharingInfo.parent_shared_folder_id` instead.\nshared_folder_id: Please use :field:`sharing_info` instead.\nsharing_info: Set if the folder is contained in a shared folder or is a shared folder mount point.\nproperty_groups: Additional information if the file has custom properties with the property template specified. Note that only properties associated with user-owned templates, not team-owned templates, can be attached to folders.\n", 
      "properties": {
        "parent_shared_folder_id": {
          "type": "string", 
          "description": "Please use :field:`FileSharingInfo.parent_shared_folder_id` or :field:`FolderSharingInfo.parent_shared_folder_id` instead."
        }, 
        "name": {
          "type": "string", 
          "description": "The last component of the path (including extension). This never contains a slash."
        }, 
        "path_display": {
          "type": "string", 
          "description": "The cased path to be used for display purposes only. In rare instances the casing will not correctly match the user's filesystem, but this behavior will match the path provided in the Core API v1, and at least the last path component will have the correct casing. Changes to only the casing of paths won't be returned by :route:`list_folder/continue`. This field will be null if the file or folder is not mounted."
        }, 
        "shared_folder_id": {
          "type": "string", 
          "description": "Please use :field:`sharing_info` instead."
        }, 
        "path_lower": {
          "type": "string", 
          "description": "The lowercased full path in the user's Dropbox. This always starts with a slash. This field will be null if the file or folder is not mounted."
        }, 
        "sharing_info": {
          "$ref": "#/definitions/FolderSharingInfo"
        }, 
        "property_groups": {
          "items": {
            "$ref": "#/definitions/PropertyGroup"
          }, 
          "type": "array", 
          "description": "Additional information if the file has custom properties with the property template specified. Note that only properties associated with user-owned templates, not team-owned templates, can be attached to folders."
        }, 
        "id": {
          "type": "string", 
          "description": "A unique identifier for the folder."
        }
      }
    }, 
    "UploadSessionOffsetError": {
      "type": "object", 
      "description": "correct_offset: The offset up to which data has been collected.\n", 
      "properties": {
        "correct_offset": {
          "type": "number", 
          "description": "The offset up to which data has been collected."
        }
      }
    }, 
    "LinkMetadata": {
      "type": "object", 
      "description": "Metadata for a shared link. This can be either a :type:`PathLinkMetadata` or :type:`CollectionLinkMetadata`.\nurl: URL of the shared link.\nvisibility: Who can access the link.\nexpires: Expiration time, if set. By default the link won't expire.\n", 
      "properties": {
        "url": {
          "type": "string", 
          "description": "URL of the shared link."
        }, 
        "expires": {
          "type": "string", 
          "description": "Expiration time, if set. By default the link won't expire."
        }, 
        "visibility": {
          "$ref": "#/definitions/Visibility"
        }
      }
    }, 
    "SharedFolderMetadata": {
      "type": "object", 
      "description": "The metadata which includes basic information about the shared folder.\naccess_type: The current user's access level for this shared folder.\nis_inside_team_folder: Whether this folder is inside of a team folder.\nis_team_folder: Whether this folder is a :link:`team folder https://www.dropbox.com/en/help/986`.\nname: The name of the this shared folder.\npolicy: Policies governing this shared folder.\npreview_url: URL for displaying a web preview of the shared folder.\nshared_folder_id: The ID of the shared folder.\ntime_invited: Timestamp indicating when the current user was invited to this shared folder.\nowner_display_names: The display names of the users that own the folder. If the folder is part of a team folder, the display names of the team admins are also included. Absent if the owner display names cannot be fetched.\nowner_team: The team that owns the folder. This field is not present if the folder is not owned by a team.\nparent_shared_folder_id: The ID of the parent shared folder. This field is present only if the folder is contained within another shared folder.\npath_lower: The lower-cased full path of this shared folder. Absent for unmounted folders.\nlink_metadata: The metadata of the shared content link to this shared folder. Absent if there is no link on the folder. This is for an unreleased feature so it may not be returned yet.\npermissions: Actions the current user may perform on the folder and its contents. The set of permissions corresponds to the FolderActions in the request.\naccess_inheritance: Whether the folder inherits its members from its parent.\n", 
      "properties": {
        "owner_team": {
          "$ref": "#/definitions/Team"
        }, 
        "parent_shared_folder_id": {
          "type": "string", 
          "description": "The ID of the parent shared folder. This field is present only if the folder is contained within another shared folder."
        }, 
        "link_metadata": {
          "$ref": "#/definitions/SharedContentLinkMetadata"
        }, 
        "time_invited": {
          "type": "string", 
          "description": "Timestamp indicating when the current user was invited to this shared folder."
        }, 
        "preview_url": {
          "type": "string", 
          "description": "URL for displaying a web preview of the shared folder."
        }, 
        "access_type": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "name": {
          "type": "string", 
          "description": "The name of the this shared folder."
        }, 
        "owner_display_names": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "The display names of the users that own the folder. If the folder is part of a team folder, the display names of the team admins are also included. Absent if the owner display names cannot be fetched."
        }, 
        "access_inheritance": {
          "$ref": "#/definitions/AccessInheritance"
        }, 
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID of the shared folder."
        }, 
        "path_lower": {
          "type": "string", 
          "description": "The lower-cased full path of this shared folder. Absent for unmounted folders."
        }, 
        "policy": {
          "$ref": "#/definitions/FolderPolicy"
        }, 
        "is_inside_team_folder": {
          "type": "boolean", 
          "description": "Whether this folder is inside of a team folder."
        }, 
        "is_team_folder": {
          "type": "boolean", 
          "description": "Whether this folder is a :link:`team folder https://www.dropbox.com/en/help/986`."
        }, 
        "permissions": {
          "items": {
            "$ref": "#/definitions/FolderPermission"
          }, 
          "type": "array", 
          "description": "Actions the current user may perform on the folder and its contents. The set of permissions corresponds to the FolderActions in the request."
        }
      }
    }, 
    "ListSharedLinksResult": {
      "type": "object", 
      "description": "links: Shared links applicable to the path argument.\nhas_more: Is true if there are additional shared links that have not been returned yet. Pass the cursor into :route:`list_shared_links` to retrieve them.\ncursor: Pass the cursor into :route:`list_shared_links` to obtain the additional links. Cursor is returned only if no path is given.\n", 
      "properties": {
        "has_more": {
          "type": "boolean", 
          "description": "Is true if there are additional shared links that have not been returned yet. Pass the cursor into :route:`list_shared_links` to retrieve them."
        }, 
        "cursor": {
          "type": "string", 
          "description": "Pass the cursor into :route:`list_shared_links` to obtain the additional links. Cursor is returned only if no path is given."
        }, 
        "links": {
          "items": {
            "$ref": "#/definitions/SharedLinkMetadata"
          }, 
          "type": "array", 
          "description": "Shared links applicable to the path argument."
        }
      }
    }, 
    "UpdateFileRequestError": {
      "type": "object", 
      "description": "There is an error updating the file request.\ndisabled_for_team: This user's Dropbox Business team doesn't allow file requests.\nother: None\nnot_found: This file request ID was not found.\nnot_a_folder: The specified path is not a folder.\napp_lacks_access: This file request is not accessible to this app. Apps with the app folder permission can only access file requests in their app folder.\nno_permission: This user doesn't have permission to access or modify this file request.\nemail_unverified: This user's email address is not verified. File requests are only available on accounts with a verified email address. Users can verify their email address :link:`here https://www.dropbox.com/help/317`.\nvalidation_error: There was an error validating the request. For example, the title was invalid, or there were disallowed characters in the destination path.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "disabled_for_team", 
            "other", 
            "not_found", 
            "not_a_folder", 
            "app_lacks_access", 
            "no_permission", 
            "email_unverified", 
            "validation_error"
          ], 
          "type": "string", 
          "title": "Choice of UpdateFileRequestError"
        }
      }
    }, 
    "CreateFolderResult": {
      "type": "object", 
      "description": "metadata: Metadata of the created folder.\n", 
      "properties": {
        "metadata": {
          "$ref": "#/definitions/FolderMetadata"
        }
      }
    }, 
    "RelocationBatchResultData": {
      "type": "object", 
      "description": "metadata: Metadata of the relocated object.\n", 
      "properties": {
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      }
    }, 
    "Visibility": {
      "type": "object", 
      "description": "Who can access a shared link. The most open visibility is :field:`public`. The default depends on many aspects, such as team and user preferences and shared folder settings.\npublic: Anyone who has received the link can access it. No login required.\nteam_only: Only members of the same team can access the link. Login is required.\npassword: A link-specific password is required to access the link. Login is not required.\nteam_and_password: Only members of the same team who have the link-specific password can access the link.\nshared_folder_only: Only members of the shared folder containing the linked file can access the link. Login is required.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "public", 
            "team_only", 
            "password", 
            "team_and_password", 
            "shared_folder_only", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of Visibility"
        }
      }
    }, 
    "DownloadArg": {
      "type": "object", 
      "description": "path: The path of the file to download.\nrev: Please specify revision in :field:`path` instead.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path of the file to download."
        }, 
        "rev": {
          "type": "string", 
          "description": "Please specify revision in :field:`path` instead."
        }
      }
    }, 
    "SharePathError": {
      "type": "object", 
      "description": "is_file: A file is at the specified path.\ninside_shared_folder: We do not support sharing a folder inside a shared folder.\ncontains_shared_folder: We do not support shared folders that contain shared folders.\ncontains_app_folder: We do not support shared folders that contain app folders.\ncontains_team_folder: We do not support shared folders that contain team folders.\nis_app_folder: We do not support sharing an app folder.\ninside_app_folder: We do not support sharing a folder inside an app folder.\nis_public_folder: A public folder can't be shared this way. Use a public link instead.\ninside_public_folder: A folder inside a public folder can't be shared this way. Use a public link instead.\nalready_shared: Folder is already shared. Contains metadata about the existing shared folder.\ninvalid_path: Path is not valid.\nis_osx_package: We do not support sharing a Mac OS X package.\ninside_osx_package: We do not support sharing a folder inside a Mac OS X package.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "is_file", 
            "inside_shared_folder", 
            "contains_shared_folder", 
            "contains_app_folder", 
            "contains_team_folder", 
            "is_app_folder", 
            "inside_app_folder", 
            "is_public_folder", 
            "inside_public_folder", 
            "already_shared", 
            "invalid_path", 
            "is_osx_package", 
            "inside_osx_package", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of SharePathError"
        }, 
        "already_shared": {
          "$ref": "#/definitions/SharedFolderMetadata"
        }
      }
    }, 
    "DeleteError": {
      "type": "object", 
      "description": "path_lookup: None\npath_write: None\ntoo_many_write_operations: There are too many write operations in user's Dropbox. Please retry this request.\ntoo_many_files: There are too many files in one request. Please retry with fewer files.\nother: None\n", 
      "properties": {
        "path_lookup": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path_lookup", 
            "path_write", 
            "too_many_write_operations", 
            "too_many_files", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of DeleteError"
        }, 
        "path_write": {
          "$ref": "#/definitions/WriteError"
        }
      }
    }, 
    "CreateFileRequestArgs": {
      "type": "object", 
      "description": "Arguments for :route:`create`.\ntitle: The title of the file request. Must not be empty.\ndestination: The path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder permission, this will be relative to the app folder.\ndeadline: The deadline for the file request. Deadlines can only be set by Pro and Business accounts.\nopen: Whether or not the file request should be open. If the file request is closed, it will not accept any file submissions, but it can be opened later.\n", 
      "properties": {
        "open": {
          "type": "boolean", 
          "description": "Whether or not the file request should be open. If the file request is closed, it will not accept any file submissions, but it can be opened later."
        }, 
        "destination": {
          "type": "string", 
          "description": "The path of the folder in the Dropbox where uploaded files will be sent. For apps with the app folder permission, this will be relative to the app folder."
        }, 
        "deadline": {
          "$ref": "#/definitions/FileRequestDeadline"
        }, 
        "title": {
          "type": "string", 
          "description": "The title of the file request. Must not be empty."
        }
      }
    }, 
    "ChangeFileMemberAccessArgs": {
      "type": "object", 
      "description": "Arguments for :route:`change_file_member_access`.\nfile: File for which we are changing a member's access.\nmember: The member whose access we are changing.\naccess_level: The new access level for the member.\n", 
      "properties": {
        "member": {
          "$ref": "#/definitions/MemberSelector"
        }, 
        "access_level": {
          "$ref": "#/definitions/AccessLevel"
        }, 
        "file": {
          "type": "string", 
          "description": "File for which we are changing a member's access."
        }
      }
    }, 
    "ListFolderContinueError": {
      "type": "object", 
      "description": "path: None\nreset: Indicates that the cursor has been invalidated. Call :route:`list_folder` to obtain a new cursor.\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "reset", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFolderContinueError"
        }
      }
    }, 
    "UnshareFolderArg": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\nleave_a_copy: If true, members of this shared folder will get a copy of this folder after it's unshared. Otherwise, it will be removed from their Dropbox. The current user, who is an owner, will always retain their copy.\n", 
      "properties": {
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }, 
        "leave_a_copy": {
          "type": "boolean", 
          "description": "If true, members of this shared folder will get a copy of this folder after it's unshared. Otherwise, it will be removed from their Dropbox. The current user, who is an owner, will always retain their copy."
        }
      }
    }, 
    "TemplateFilterBase": {
      "type": "object", 
      "description": "filter_some: Only templates with an ID in the supplied list will be returned (a subset of templates will be returned).\nother: None\n", 
      "properties": {
        "filter_some": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "Only templates with an ID in the supplied list will be returned (a subset of templates will be returned)."
        }, 
        ".tag": {
          "enum": [
            "filter_some", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of TemplateFilterBase"
        }
      }
    }, 
    "UserOnPaperDocFilter": {
      "type": "object", 
      "description": "visited: all users who have visited the Paper doc.\nshared: All uses who are shared on the Paper doc. This includes all users who have visited the Paper doc as well as those who have not.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "visited", 
            "shared", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of UserOnPaperDocFilter"
        }
      }
    }, 
    "UploadSessionFinishArg": {
      "type": "object", 
      "description": "cursor: Contains the upload session ID and the offset.\ncommit: Contains the path and other optional modifiers for the commit.\n", 
      "properties": {
        "cursor": {
          "$ref": "#/definitions/UploadSessionCursor"
        }, 
        "commit": {
          "$ref": "#/definitions/CommitInfo"
        }
      }
    }, 
    "FullAccount": {
      "type": "object", 
      "description": "Detailed information about the current user's account.\naccount_id: The user's unique Dropbox ID.\nname: Details of a user's name.\nemail: The user's e-mail address. Do not rely on this without checking the :field:`email_verified` field. Even then, it's possible that the user has since lost access to their e-mail.\nemail_verified: Whether the user has verified their e-mail address.\ndisabled: Whether the user has been disabled.\nlocale: The language that the user specified. Locale tags will be :link:`IETF language tags http://en.wikipedia.org/wiki/IETF_language_tag`.\nreferral_link: The user's :link:`referral link https://www.dropbox.com/referrals`.\nis_paired: Whether the user has a personal and work account. If the current account is personal, then :field:`team` will always be :val:`null`, but :field:`is_paired` will indicate if a work account is linked.\naccount_type: What type of account this user has.\nroot_info: The root info for this account.\nprofile_photo_url: URL for the photo representing the user, if one is set.\ncountry: The user's two-letter country code, if available. Country codes are based on :link:`ISO 3166-1 http://en.wikipedia.org/wiki/ISO_3166-1`.\nteam: If this account is a member of a team, information about that team.\nteam_member_id: This account's unique team member id. This field will only be present if :field:`team` is present.\n", 
      "properties": {
        "referral_link": {
          "type": "string", 
          "description": "The user's :link:`referral link https://www.dropbox.com/referrals`."
        }, 
        "account_type": {
          "$ref": "#/definitions/AccountType"
        }, 
        "account_id": {
          "type": "string", 
          "description": "The user's unique Dropbox ID."
        }, 
        "locale": {
          "type": "string", 
          "description": "The language that the user specified. Locale tags will be :link:`IETF language tags http://en.wikipedia.org/wiki/IETF_language_tag`."
        }, 
        "email_verified": {
          "type": "boolean", 
          "description": "Whether the user has verified their e-mail address."
        }, 
        "team_member_id": {
          "type": "string", 
          "description": "This account's unique team member id. This field will only be present if :field:`team` is present."
        }, 
        "root_info": {
          "$ref": "#/definitions/RootInfo"
        }, 
        "disabled": {
          "type": "boolean", 
          "description": "Whether the user has been disabled."
        }, 
        "is_paired": {
          "type": "boolean", 
          "description": "Whether the user has a personal and work account. If the current account is personal, then :field:`team` will always be :val:`null`, but :field:`is_paired` will indicate if a work account is linked."
        }, 
        "team": {
          "$ref": "#/definitions/FullTeam"
        }, 
        "country": {
          "type": "string", 
          "description": "The user's two-letter country code, if available. Country codes are based on :link:`ISO 3166-1 http://en.wikipedia.org/wiki/ISO_3166-1`."
        }, 
        "email": {
          "type": "string", 
          "description": "The user's e-mail address. Do not rely on this without checking the :field:`email_verified` field. Even then, it's possible that the user has since lost access to their e-mail."
        }, 
        "profile_photo_url": {
          "type": "string", 
          "description": "URL for the photo representing the user, if one is set."
        }, 
        "name": {
          "$ref": "#/definitions/Name"
        }
      }
    }, 
    "CreateSharedLinkError": {
      "type": "object", 
      "description": "path: None\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of CreateSharedLinkError"
        }
      }
    }, 
    "PathLinkMetadata": {
      "type": "object", 
      "description": "Metadata for a path-based shared link.\nurl: URL of the shared link.\nvisibility: Who can access the link.\npath: Path in user's Dropbox.\nexpires: Expiration time, if set. By default the link won't expire.\n", 
      "properties": {
        "url": {
          "type": "string", 
          "description": "URL of the shared link."
        }, 
        "path": {
          "type": "string", 
          "description": "Path in user's Dropbox."
        }, 
        "expires": {
          "type": "string", 
          "description": "Expiration time, if set. By default the link won't expire."
        }, 
        "visibility": {
          "$ref": "#/definitions/Visibility"
        }
      }
    }, 
    "TransferFolderArg": {
      "type": "object", 
      "description": "shared_folder_id: The ID for the shared folder.\nto_dropbox_id: A account or team member ID to transfer ownership to.\n", 
      "properties": {
        "shared_folder_id": {
          "type": "string", 
          "description": "The ID for the shared folder."
        }, 
        "to_dropbox_id": {
          "type": "string", 
          "description": "A account or team member ID to transfer ownership to."
        }
      }
    }, 
    "AlphaGetMetadataError": {
      "type": "object", 
      "description": "path: None\nproperties_error: None\n", 
      "properties": {
        "properties_error": {
          "$ref": "#/definitions/LookUpPropertiesError"
        }, 
        "path": {
          "$ref": "#/definitions/LookupError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "properties_error"
          ], 
          "type": "string", 
          "title": "Choice of AlphaGetMetadataError"
        }
      }
    }, 
    "RemoveFolderMemberError": {
      "type": "object", 
      "description": "access_error: None\nmember_error: None\nfolder_owner: The target user is the owner of the shared folder. You can't remove this user until ownership has been transferred to another member.\ngroup_access: The target user has access to the shared folder via a group.\nteam_folder: This action cannot be performed on a team shared folder.\nno_permission: The current user does not have permission to perform this action.\ntoo_many_files: This shared folder has too many files for leaving a copy. You can still remove this user without leaving a copy.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "member_error", 
            "folder_owner", 
            "group_access", 
            "team_folder", 
            "no_permission", 
            "too_many_files", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of RemoveFolderMemberError"
        }, 
        "member_error": {
          "$ref": "#/definitions/SharedFolderMemberError"
        }
      }
    }, 
    "GetFileRequestError": {
      "type": "object", 
      "description": "There was an error retrieving the specified file request.\ndisabled_for_team: This user's Dropbox Business team doesn't allow file requests.\nother: None\nnot_found: This file request ID was not found.\nnot_a_folder: The specified path is not a folder.\napp_lacks_access: This file request is not accessible to this app. Apps with the app folder permission can only access file requests in their app folder.\nno_permission: This user doesn't have permission to access or modify this file request.\nemail_unverified: This user's email address is not verified. File requests are only available on accounts with a verified email address. Users can verify their email address :link:`here https://www.dropbox.com/help/317`.\nvalidation_error: There was an error validating the request. For example, the title was invalid, or there were disallowed characters in the destination path.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "disabled_for_team", 
            "other", 
            "not_found", 
            "not_a_folder", 
            "app_lacks_access", 
            "no_permission", 
            "email_unverified", 
            "validation_error"
          ], 
          "type": "string", 
          "title": "Choice of GetFileRequestError"
        }
      }
    }, 
    "FileRequestDeadline": {
      "type": "object", 
      "description": "deadline: The deadline for this file request.\nallow_late_uploads: If set, allow uploads after the deadline has passed. These     uploads will be marked overdue.\n", 
      "properties": {
        "deadline": {
          "type": "string", 
          "description": "The deadline for this file request."
        }, 
        "allow_late_uploads": {
          "$ref": "#/definitions/GracePeriod"
        }
      }
    }, 
    "InsufficientPlan": {
      "type": "object", 
      "description": "message: A message to tell the user to upgrade in order to support expected action.\nupsell_url: A URL to send the user to in order to obtain the account type they need, e.g. upgrading. Absent if there is no action the user can take to upgrade.\n", 
      "properties": {
        "message": {
          "type": "string", 
          "description": "A message to tell the user to upgrade in order to support expected action."
        }, 
        "upsell_url": {
          "type": "string", 
          "description": "A URL to send the user to in order to obtain the account type they need, e.g. upgrading. Absent if there is no action the user can take to upgrade."
        }
      }
    }, 
    "PaperDocUpdatePolicy": {
      "type": "object", 
      "description": "append: The content will be appended to the doc.\nprepend: The content will be prepended to the doc.\nNote: the doc title will not be affected.\noverwrite_all: The document will be overwitten at the head with the provided content.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "append", 
            "prepend", 
            "overwrite_all", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PaperDocUpdatePolicy"
        }
      }
    }, 
    "UploadSessionFinishBatchArg": {
      "type": "object", 
      "description": "entries: Commit information for each file in the batch.\n", 
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/UploadSessionFinishArg"
          }, 
          "type": "array", 
          "description": "Commit information for each file in the batch."
        }
      }
    }, 
    "Dimensions": {
      "type": "object", 
      "description": "Dimensions for a photo or video.\nheight: Height of the photo/video.\nwidth: Width of the photo/video.\n", 
      "properties": {
        "width": {
          "type": "number", 
          "description": "Width of the photo/video."
        }, 
        "height": {
          "type": "number", 
          "description": "Height of the photo/video."
        }
      }
    }, 
    "PropertiesSearchError": {
      "type": "object", 
      "description": "property_group_lookup: None\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "property_group_lookup", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PropertiesSearchError"
        }, 
        "property_group_lookup": {
          "$ref": "#/definitions/LookUpPropertiesError"
        }
      }
    }, 
    "GetFileMetadataError": {
      "type": "object", 
      "description": "Error result for :route:`get_file_metadata`.\nuser_error: None\naccess_error: None\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "user_error", 
            "access_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GetFileMetadataError"
        }, 
        "user_error": {
          "$ref": "#/definitions/SharingUserError"
        }
      }
    }, 
    "GetTemplateResult": {
      "type": "object", 
      "description": "name: Display name for the template. Template names can be up to 256 bytes.\ndescription: Description for the template. Template descriptions can be up to 1024 bytes.\nfields: Definitions of the property fields associated with this template. There can be up to 32 properties in a single template.\n", 
      "properties": {
        "fields": {
          "items": {
            "$ref": "#/definitions/PropertyFieldTemplate"
          }, 
          "type": "array", 
          "description": "Definitions of the property fields associated with this template. There can be up to 32 properties in a single template."
        }, 
        "name": {
          "type": "string", 
          "description": "Display name for the template. Template names can be up to 256 bytes."
        }, 
        "description": {
          "type": "string", 
          "description": "Description for the template. Template descriptions can be up to 1024 bytes."
        }
      }
    }, 
    "LookupError": {
      "type": "object", 
      "description": "malformed_path: None\nnot_found: There is nothing at the given path.\nnot_file: We were expecting a file, but the given path refers to something that isn't a file.\nnot_folder: We were expecting a folder, but the given path refers to something that isn't a folder.\nrestricted_content: The file cannot be transferred because the content is restricted.  For example, sometimes there are legal restrictions due to copyright claims.\nother: None\n", 
      "properties": {
        "malformed_path": {
          "type": "string"
        }, 
        ".tag": {
          "enum": [
            "malformed_path", 
            "not_found", 
            "not_file", 
            "not_folder", 
            "restricted_content", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of LookupError"
        }
      }
    }, 
    "CreateFolderBatchJobStatus": {
      "type": "object", 
      "description": "in_progress: The asynchronous job is still in progress.\ncomplete: The batch create folder has finished.\nfailed: The batch create folder has failed.\nother: None\n", 
      "properties": {
        "failed": {
          "$ref": "#/definitions/CreateFolderBatchError"
        }, 
        ".tag": {
          "enum": [
            "in_progress", 
            "complete", 
            "failed", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of CreateFolderBatchJobStatus"
        }, 
        "complete": {
          "$ref": "#/definitions/CreateFolderBatchResult"
        }
      }
    }, 
    "ListTemplateResult": {
      "type": "object", 
      "description": "template_ids: List of identifiers for templates added by  See :route:`templates/add_for_user` or :route:`templates/add_for_team`.\n", 
      "properties": {
        "template_ids": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "List of identifiers for templates added by  See :route:`templates/add_for_user` or :route:`templates/add_for_team`."
        }
      }
    }, 
    "TemplateError": {
      "type": "object", 
      "description": "template_not_found: Template does not exist for the given identifier.\nrestricted_content: You do not have permission to modify this template.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "template_not_found", 
            "restricted_content", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of TemplateError"
        }, 
        "template_not_found": {
          "type": "string", 
          "description": "Template does not exist for the given identifier."
        }
      }
    }, 
    "GetCopyReferenceResult": {
      "type": "object", 
      "description": "metadata: Metadata of the file or folder.\ncopy_reference: A copy reference to the file or folder.\nexpires: The expiration date of the copy reference. This value is currently set to be far enough in the future so that expiration is effectively not an issue.\n", 
      "properties": {
        "expires": {
          "type": "string", 
          "description": "The expiration date of the copy reference. This value is currently set to be far enough in the future so that expiration is effectively not an issue."
        }, 
        "copy_reference": {
          "type": "string", 
          "description": "A copy reference to the file or folder."
        }, 
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      }
    }, 
    "PropertiesSearchMode": {
      "type": "object", 
      "description": "field_name: Search for a value associated with this field name.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "field_name", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of PropertiesSearchMode"
        }, 
        "field_name": {
          "type": "string", 
          "description": "Search for a value associated with this field name."
        }
      }
    }, 
    "RelocationArg": {
      "type": "object", 
      "description": "from_path: Path in the user's Dropbox to be copied or moved.\nto_path: Path in the user's Dropbox that is the destination.\nallow_shared_folder: If true, :route:`copy` will copy contents in shared folder, otherwise :field:`RelocationError.cant_copy_shared_folder` will be returned if :field:`from_path` contains shared folder. This field is always true for :route:`move`.\nautorename: If there's a conflict, have the Dropbox server try to autorename the file to avoid the conflict.\nallow_ownership_transfer: Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does not apply to copies.\n", 
      "properties": {
        "allow_ownership_transfer": {
          "type": "boolean", 
          "description": "Allow moves by owner even if it would result in an ownership transfer for the content being moved. This does not apply to copies."
        }, 
        "from_path": {
          "type": "string", 
          "description": "Path in the user's Dropbox to be copied or moved."
        }, 
        "to_path": {
          "type": "string", 
          "description": "Path in the user's Dropbox that is the destination."
        }, 
        "autorename": {
          "type": "boolean", 
          "description": "If there's a conflict, have the Dropbox server try to autorename the file to avoid the conflict."
        }, 
        "allow_shared_folder": {
          "type": "boolean", 
          "description": "If true, :route:`copy` will copy contents in shared folder, otherwise :field:`RelocationError.cant_copy_shared_folder` will be returned if :field:`from_path` contains shared folder. This field is always true for :route:`move`."
        }
      }
    }, 
    "AlphaGetMetadataArg": {
      "type": "object", 
      "description": "path: The path of a file or folder on Dropbox.\ninclude_media_info: If true, :field:`FileMetadata.media_info` is set for photo and video.\ninclude_deleted: If true, :type:`DeletedMetadata` will be returned for deleted file or folder, otherwise :field:`LookupError.not_found` will be returned.\ninclude_has_explicit_shared_members: If true, the results will include a flag for each file indicating whether or not  that file has any explicit members.\ninclude_property_groups: If set to a valid list of template IDs, :field:`FileMetadata.property_groups` is set if there exists property data associated with the file and each of the listed templates.\ninclude_property_templates: If set to a valid list of template IDs, :field:`FileMetadata.property_groups` is set for files with custom properties.\n", 
      "properties": {
        "include_property_groups": {
          "$ref": "#/definitions/TemplateFilterBase"
        }, 
        "include_property_templates": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "If set to a valid list of template IDs, :field:`FileMetadata.property_groups` is set for files with custom properties."
        }, 
        "include_has_explicit_shared_members": {
          "type": "boolean", 
          "description": "If true, the results will include a flag for each file indicating whether or not  that file has any explicit members."
        }, 
        "include_deleted": {
          "type": "boolean", 
          "description": "If true, :type:`DeletedMetadata` will be returned for deleted file or folder, otherwise :field:`LookupError.not_found` will be returned."
        }, 
        "include_media_info": {
          "type": "boolean", 
          "description": "If true, :field:`FileMetadata.media_info` is set for photo and video."
        }, 
        "path": {
          "type": "string", 
          "description": "The path of a file or folder on Dropbox."
        }
      }
    }, 
    "ListUsersCursorError": {
      "type": "object", 
      "description": "insufficient_permissions: Your account does not have permissions to perform this action.\nother: None\ndoc_not_found: The required doc was not found.\ncursor_error: None\n", 
      "properties": {
        "cursor_error": {
          "$ref": "#/definitions/PaperApiCursorError"
        }, 
        ".tag": {
          "enum": [
            "insufficient_permissions", 
            "other", 
            "doc_not_found", 
            "cursor_error"
          ], 
          "type": "string", 
          "title": "Choice of ListUsersCursorError"
        }
      }
    }, 
    "UploadSessionCursor": {
      "type": "object", 
      "description": "session_id: The upload session ID (returned by :route:`upload_session/start`).\noffset: The amount of data that has been uploaded so far. We use this to make sure upload data isn't lost or duplicated in the event of a network error.\n", 
      "properties": {
        "session_id": {
          "type": "string", 
          "description": "The upload session ID (returned by :route:`upload_session/start`)."
        }, 
        "offset": {
          "type": "number", 
          "description": "The amount of data that has been uploaded so far. We use this to make sure upload data isn't lost or duplicated in the event of a network error."
        }
      }
    }, 
    "ListFolderMembersContinueError": {
      "type": "object", 
      "description": "access_error: None\ninvalid_cursor: :field:`ListFolderMembersContinueArg.cursor` is invalid.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharedFolderAccessError"
        }, 
        ".tag": {
          "enum": [
            "access_error", 
            "invalid_cursor", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFolderMembersContinueError"
        }
      }
    }, 
    "RestoreArg": {
      "type": "object", 
      "description": "path: The path to the file you want to restore.\nrev: The revision to restore for the file.\n", 
      "properties": {
        "path": {
          "type": "string", 
          "description": "The path to the file you want to restore."
        }, 
        "rev": {
          "type": "string", 
          "description": "The revision to restore for the file."
        }
      }
    }, 
    "MediaMetadata": {
      "type": "object", 
      "description": "Metadata for a photo or video.\ndimensions: Dimension of the photo/video.\nlocation: The GPS coordinate of the photo/video.\ntime_taken: The timestamp when the photo/video is taken.\n", 
      "properties": {
        "dimensions": {
          "$ref": "#/definitions/Dimensions"
        }, 
        "location": {
          "$ref": "#/definitions/GpsCoordinates"
        }, 
        "time_taken": {
          "type": "string", 
          "description": "The timestamp when the photo/video is taken."
        }
      }
    }, 
    "DeleteBatchJobStatus": {
      "type": "object", 
      "description": "in_progress: The asynchronous job is still in progress.\ncomplete: The batch delete has finished.\nfailed: The batch delete has failed.\nother: None\n", 
      "properties": {
        "failed": {
          "$ref": "#/definitions/DeleteBatchError"
        }, 
        ".tag": {
          "enum": [
            "in_progress", 
            "complete", 
            "failed", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of DeleteBatchJobStatus"
        }, 
        "complete": {
          "$ref": "#/definitions/DeleteBatchResult"
        }
      }
    }, 
    "RemoveFileMemberError": {
      "type": "object", 
      "description": "Errors for :route:`remove_file_member_2`.\nuser_error: None\naccess_error: None\nno_explicit_access: This member does not have explicit access to the file and therefore cannot be removed. The return value is the access that a user might have to the file from a parent folder.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "user_error", 
            "access_error", 
            "no_explicit_access", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of RemoveFileMemberError"
        }, 
        "user_error": {
          "$ref": "#/definitions/SharingUserError"
        }, 
        "no_explicit_access": {
          "$ref": "#/definitions/MemberAccessLevelResult"
        }
      }
    }, 
    "CreateFolderError": {
      "type": "object", 
      "description": "path: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/WriteError"
        }, 
        ".tag": {
          "enum": [
            "path"
          ], 
          "type": "string", 
          "title": "Choice of CreateFolderError"
        }
      }
    }, 
    "ListRevisionsMode": {
      "type": "object", 
      "description": "path: Returns revisions with the same file path as identified by the latest file entry at the given file path or id.\nid: Returns revisions with the same file id as identified by the latest file entry at the given file path or id.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "path", 
            "id", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListRevisionsMode"
        }
      }
    }, 
    "DeleteBatchLaunch": {
      "type": "object", 
      "description": "Result returned by :route:`delete_batch` that may either launch an asynchronous job or complete synchronously.\nasync_job_id: This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job.\ncomplete: None\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "async_job_id", 
            "complete", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of DeleteBatchLaunch"
        }, 
        "async_job_id": {
          "type": "string", 
          "description": "This response indicates that the processing is asynchronous. The string is an id that can be used to obtain the status of the asynchronous job."
        }, 
        "complete": {
          "$ref": "#/definitions/DeleteBatchResult"
        }
      }
    }, 
    "TokenFromOAuth1Arg": {
      "type": "object", 
      "description": "oauth1_token: The supplied OAuth 1.0 access token.\noauth1_token_secret: The token secret associated with the supplied access token.\n", 
      "properties": {
        "oauth1_token": {
          "type": "string", 
          "description": "The supplied OAuth 1.0 access token."
        }, 
        "oauth1_token_secret": {
          "type": "string", 
          "description": "The token secret associated with the supplied access token."
        }
      }
    }, 
    "ListUsersOnPaperDocResponse": {
      "type": "object", 
      "description": "invitees: List of email addresses with their respective permission levels that are invited on the Paper doc.\nusers: List of users with their respective permission levels that are invited on the Paper folder.\ndoc_owner: The Paper doc owner. This field is populated on every single response.\ncursor: Pass the cursor into :route:`docs/users/list/continue` to paginate through all users. The cursor preserves all properties as specified in the original call to :route:`docs/users/list`.\nhas_more: Will be set to True if a subsequent call with the provided cursor to :route:`docs/users/list/continue` returns immediately with some results. If set to False please allow some delay before making another call to :route:`docs/users/list/continue`.\n", 
      "properties": {
        "cursor": {
          "$ref": "#/definitions/Cursor"
        }, 
        "has_more": {
          "type": "boolean", 
          "description": "Will be set to True if a subsequent call with the provided cursor to :route:`docs/users/list/continue` returns immediately with some results. If set to False please allow some delay before making another call to :route:`docs/users/list/continue`."
        }, 
        "doc_owner": {
          "$ref": "#/definitions/UserInfo"
        }, 
        "users": {
          "items": {
            "$ref": "#/definitions/UserInfoWithPermissionLevel"
          }, 
          "type": "array", 
          "description": "List of users with their respective permission levels that are invited on the Paper folder."
        }, 
        "invitees": {
          "items": {
            "$ref": "#/definitions/InviteeInfoWithPermissionLevel"
          }, 
          "type": "array", 
          "description": "List of email addresses with their respective permission levels that are invited on the Paper doc."
        }
      }
    }, 
    "GetThumbnailBatchError": {
      "type": "object", 
      "description": "too_many_files: The operation involves more than 25 files.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "too_many_files", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GetThumbnailBatchError"
        }
      }
    }, 
    "ListFileMembersIndividualResult": {
      "type": "object", 
      "description": "result: The results of the query for this file if it was successful.\naccess_error: The result of the query for this file if it was an error.\nother: None\n", 
      "properties": {
        "access_error": {
          "$ref": "#/definitions/SharingFileAccessError"
        }, 
        ".tag": {
          "enum": [
            "result", 
            "access_error", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListFileMembersIndividualResult"
        }, 
        "result": {
          "$ref": "#/definitions/ListFileMembersCountResult"
        }
      }
    }, 
    "PropertyField": {
      "type": "object", 
      "description": "Raw key/value data to be associated with a Dropbox file. Property fields are added to Dropbox files as a :type:`PropertyGroup`.\nname: Key of the property field associated with a file and template. Keys can be up to 256 bytes.\nvalue: Value of the property field associated with a file and template. Values can be up to 1024 bytes.\n", 
      "properties": {
        "name": {
          "type": "string", 
          "description": "Key of the property field associated with a file and template. Keys can be up to 256 bytes."
        }, 
        "value": {
          "type": "string", 
          "description": "Value of the property field associated with a file and template. Values can be up to 1024 bytes."
        }
      }
    }, 
    "PropertiesSearchResult": {
      "type": "object", 
      "description": "matches: A list (possibly empty) of matches for the query.\ncursor: Pass the cursor into :route:`properties/search/continue` to continue to receive search results. Cursor will be null when there are no more results.\n", 
      "properties": {
        "matches": {
          "items": {
            "$ref": "#/definitions/PropertiesSearchMatch"
          }, 
          "type": "array", 
          "description": "A list (possibly empty) of matches for the query."
        }, 
        "cursor": {
          "type": "string", 
          "description": "Pass the cursor into :route:`properties/search/continue` to continue to receive search results. Cursor will be null when there are no more results."
        }
      }
    }, 
    "ListPaperDocsFilterBy": {
      "type": "object", 
      "description": "docs_accessed: Fetches all Paper doc IDs that the user has ever accessed.\ndocs_created: Fetches only the Paper doc IDs that the user has created.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "docs_accessed", 
            "docs_created", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of ListPaperDocsFilterBy"
        }
      }
    }, 
    "AccessInheritance": {
      "type": "object", 
      "description": "Information about the inheritance policy of a shared folder.\ninherit: The shared folder inherits its members from the parent folder.\nno_inherit: The shared folder does not inherit its members from the parent folder.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "inherit", 
            "no_inherit", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of AccessInheritance"
        }
      }
    }, 
    "ListFolderLongpollResult": {
      "type": "object", 
      "description": "changes: Indicates whether new changes are available. If true, call :route:`list_folder/continue` to retrieve the changes.\nbackoff: If present, backoff for at least this many seconds before calling :route:`list_folder/longpoll` again.\n", 
      "properties": {
        "changes": {
          "type": "boolean", 
          "description": "Indicates whether new changes are available. If true, call :route:`list_folder/continue` to retrieve the changes."
        }, 
        "backoff": {
          "type": "number", 
          "description": "If present, backoff for at least this many seconds before calling :route:`list_folder/longpoll` again."
        }
      }
    }, 
    "AclUpdatePolicy": {
      "type": "object", 
      "description": "Who can change a shared folder's access control list (ACL). In other words, who can add, remove, or change the privileges of members.\nowner: Only the owner can update the ACL.\neditors: Any editor can update the ACL. This may be further restricted to editors on the same team.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "owner", 
            "editors", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of AclUpdatePolicy"
        }
      }
    }, 
    "ListFileMembersContinueArg": {
      "type": "object", 
      "description": "Arguments for :route:`list_file_members/continue`.\ncursor: The cursor returned by your last call to :route:`list_file_members`, :route:`list_file_members/continue`, or :route:`list_file_members/batch`.\n", 
      "properties": {
        "cursor": {
          "type": "string", 
          "description": "The cursor returned by your last call to :route:`list_file_members`, :route:`list_file_members/continue`, or :route:`list_file_members/batch`."
        }
      }
    }, 
    "ListPaperDocsResponse": {
      "type": "object", 
      "description": "doc_ids: The list of Paper doc IDs that can be used to access the given Paper docs or supplied to other API methods. The list is sorted in the order specified by the initial call to :route:`docs/list`.\ncursor: Pass the cursor into :route:`docs/list/continue` to paginate through all files. The cursor preserves all properties as specified in the original call to :route:`docs/list`.\nhas_more: Will be set to True if a subsequent call with the provided cursor to :route:`docs/list/continue` returns immediately with some results. If set to False please allow some delay before making another call to :route:`docs/list/continue`.\n", 
      "properties": {
        "cursor": {
          "$ref": "#/definitions/Cursor"
        }, 
        "has_more": {
          "type": "boolean", 
          "description": "Will be set to True if a subsequent call with the provided cursor to :route:`docs/list/continue` returns immediately with some results. If set to False please allow some delay before making another call to :route:`docs/list/continue`."
        }, 
        "doc_ids": {
          "items": {
            "type": "string"
          }, 
          "type": "array", 
          "description": "The list of Paper doc IDs that can be used to access the given Paper docs or supplied to other API methods. The list is sorted in the order specified by the initial call to :route:`docs/list`."
        }
      }
    }, 
    "RelinquishFileMembershipArg": {
      "type": "object", 
      "description": "file: The path or id for the file.\n", 
      "properties": {
        "file": {
          "type": "string", 
          "description": "The path or id for the file."
        }
      }
    }, 
    "GetSharedLinksResult": {
      "type": "object", 
      "description": "links: Shared links applicable to the path argument.\n", 
      "properties": {
        "links": {
          "items": {
            "$ref": "#/definitions/LinkMetadata"
          }, 
          "type": "array", 
          "description": "Shared links applicable to the path argument."
        }
      }
    }, 
    "CreateFolderEntryError": {
      "type": "object", 
      "description": "path: None\nother: None\n", 
      "properties": {
        "path": {
          "$ref": "#/definitions/WriteError"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of CreateFolderEntryError"
        }
      }
    }, 
    "LinkAction": {
      "type": "object", 
      "description": "Actions that can be performed on a link.\nchange_access_level: Change the access level of the link.\nchange_audience: Change the audience of the link.\nremove_expiry: Remove the expiry date of the link.\nremove_password: Remove the password of the link.\nset_expiry: Create or modify the expiry date of the link.\nset_password: Create or modify the password of the link.\nother: None\n", 
      "properties": {
        ".tag": {
          "enum": [
            "change_access_level", 
            "change_audience", 
            "remove_expiry", 
            "remove_password", 
            "set_expiry", 
            "set_password", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of LinkAction"
        }
      }
    }, 
    "LinkExpiry": {
      "type": "object", 
      "description": "remove_expiry: Remove the currently set expiry for the link.\nset_expiry: Set a new expiry or change an existing expiry.\nother: None\n", 
      "properties": {
        "set_expiry": {
          "type": "string", 
          "description": "Set a new expiry or change an existing expiry."
        }, 
        ".tag": {
          "enum": [
            "remove_expiry", 
            "set_expiry", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of LinkExpiry"
        }
      }
    }, 
    "PendingUploadMode": {
      "type": "object", 
      "description": "Flag to indicate pending upload default (for linking to not-yet-existing paths).\nfile: Assume pending uploads are files.\nfolder: Assume pending uploads are folders.\n", 
      "properties": {
        ".tag": {
          "enum": [
            "file", 
            "folder"
          ], 
          "type": "string", 
          "title": "Choice of PendingUploadMode"
        }
      }
    }, 
    "GetSharedLinksError": {
      "type": "object", 
      "description": "path: None\nother: None\n", 
      "properties": {
        "path": {
          "type": "string"
        }, 
        ".tag": {
          "enum": [
            "path", 
            "other"
          ], 
          "type": "string", 
          "title": "Choice of GetSharedLinksError"
        }
      }
    }, 
    "RelocationBatchJobStatus": {
      "type": "object", 
      "description": "in_progress: The asynchronous job is still in progress.\ncomplete: The copy or move batch job has finished.\nfailed: The copy or move batch job has failed with exception.\n", 
      "properties": {
        "failed": {
          "$ref": "#/definitions/RelocationBatchError"
        }, 
        ".tag": {
          "enum": [
            "in_progress", 
            "complete", 
            "failed"
          ], 
          "type": "string", 
          "title": "Choice of RelocationBatchJobStatus"
        }, 
        "complete": {
          "$ref": "#/definitions/RelocationBatchResult"
        }
      }
    }
  }, 
  "swagger": "2.0", 
  "consumes": [
    "application/json"
  ]
}
